// <auto-generated />
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Text;

namespace TreasureChest.Policies
{
    public class DefaultConstructionPolicy : GlobalChestPolicyBase, 
        IConstructionPolicy, 
        IRegistrationValidationPolicy
    {
        public void Validate(ServiceRegistration registration)
        {
            //if (registration.RegistrationHandler.RequiresFetchingValidation)
            //    GetConstructor(registration.ImplType, null);
        }

        public bool CanBeCreated(Type type, ResolvingContext context)
        {
            return true;
            //ConstructorInjectionInfo constructorInjection = GetConstructor(type, null);

            //IAutowiringConstructorArgumentTypesPolicy autowiringPolicy
            //    = chest.FindPolicyOf<IAutowiringConstructorArgumentTypesPolicy>();

            //bool isAvailable = true;
            //foreach (ParameterInfo parameterInfo in constructor.GetParameters())
            //{
            //    if (autowiringPolicy.ShouldArgumentTypeBeAutowired(parameterInfo.ParameterType))
            //    {
            //        if (false == chest.CanBeFetched(parameterInfo.ParameterType))
            //        {
            //            isAvailable = false;
            //            break;
            //        }
            //    }
            //    else
            //    {
            //        throw new NotImplementedException();
            //    }
            //}

            //if (isAvailable)
            //    return true;

            //return false;
        }

        public object CreateInstance(
            ServiceRegistration registration,
            ResolvingContext context)
        {
            IDictionary<string, object> args = MergeRegistrationWithCallingArgs(
                registration.Args,
                context.Args);
            context.MarkCallingArgsAsConsumed();

            try
            {
                context.PushImplementationType(registration.ImplType);

                ConstructorInjectionInfo constructorInjection = GetConstructor(
                    registration.ImplType, 
                    args);
                return CreateInstance(constructorInjection, registration, context);
            }
            finally
            {
                context.PopType();
            }
        }

        private ConstructorInjectionInfo GetConstructor(
            Type type, 
            IDictionary<string, object> args)
        {
            List<ConstructorInfo> constructors = new List<ConstructorInfo>();
            constructors.AddRange(type.GetConstructors());

            constructors.Sort((a, b) => -a.GetParameters().Length.CompareTo(b.GetParameters().Length));

            if (constructors.Count == 0)
            {
                string message = string.Format(
                    CultureInfo.InvariantCulture,
                    "Could not create instance of {0}, none of its constructors can be used within the chest.",
                    type.FullName);
                throw new ChestException(message);                
            }

            if (args.Count == 0)
            {
                if (constructors.Count > 1
                    && constructors[0].GetParameters().Length == constructors[1].GetParameters().Length)
                {
                    // two or more constructors with the same number of arguments
                    // we must test them each
                    int argsCount = constructors[0].GetParameters().Length;

                    for (int i = 0; i < constructors.Count; i++)
                    {
                        if (constructors[i].GetParameters().Length == argsCount)
                        {
                            ConstructorInjectionInfo constructorInjectionInfo1 = new ConstructorInjectionInfo(
                                Chest.ChestPolicies,
                                constructors[i],
                                args);
                            if (constructorInjectionInfo1.IsMatch)
                                return constructorInjectionInfo1;                            
                        }
                    }

                    string message = string.Format(
                        CultureInfo.InvariantCulture,
                        "The type {0} has two or more candidate constructors with the same number of arguments, you must specify which one to use.",
                        type.FullName);
                    throw new ChestException(message);
                }

                ConstructorInjectionInfo constructorInjectionInfo = new ConstructorInjectionInfo(
                    Chest.ChestPolicies, 
                    constructors[0],
                    args);

                if (!constructorInjectionInfo.IsMatch)
                {
                    string message = string.Format(
                        CultureInfo.InvariantCulture,
                        "The type's {0} candidate constructor has some manually wired arguments, but there are no values.",
                        type.FullName);
                    throw new ChestException(message);                    
                }

                return constructorInjectionInfo;
            }

            return FindConstructorByArguments(type, constructors, args);
        }

        private ConstructorInjectionInfo FindConstructorByArguments(
            Type type,
            IEnumerable<ConstructorInfo> constructors, 
            IDictionary<string, object> args)
        {
            foreach (ConstructorInfo constructor in constructors)
            {
                ConstructorInjectionInfo constructorInjectionInfo = new ConstructorInjectionInfo(
                    Chest.ChestPolicies, 
                    constructor,
                    args);
                if (constructorInjectionInfo.IsMatch)
                    return constructorInjectionInfo;
            }

            StringBuilder argsBuilder = new StringBuilder();
            foreach (KeyValuePair<string, object> arg in args)
            {
                if (argsBuilder.Length > 0)
                    argsBuilder.Append(", ");
                argsBuilder.Append(arg.Key);
            }

            string message = string.Format(
                CultureInfo.InvariantCulture,
                "Could not create instance of {0}, none of its constructors can be used within the chest (args: '{1}').",
                type.FullName,
                argsBuilder);
            throw new ChestException(message);
        }

        private object CreateInstance(
            ConstructorInjectionInfo constructorInjection, 
            ServiceRegistration registration,
            ResolvingContext context)
        {
            HashSet<object> createdDependencies = new HashSet<object>();
            foreach (ParameterInfo parameter in constructorInjection.EnumerateParameters())
            {
                if (!constructorInjection.IsManualParameter(parameter.Name))
                {
                    Type innerEnumerableType;
                    if (parameter.ParameterType.IsGenericEnumerable(out innerEnumerableType))
                    {
                        Type genericListType = typeof(List<>).MakeGenericType(innerEnumerableType);
                        object genericList = Activator.CreateInstance(genericListType);
                        MethodInfo addMethod = genericListType.GetMethod("Add");

                        foreach (object dependency in Chest.FetchAll(innerEnumerableType))
                        {
                            createdDependencies.Add(dependency);
                            addMethod.Invoke(genericList, new[] { dependency });
                        }

                        constructorInjection.SetParameterValue(parameter.Name, genericList);
                    }
                    else
                    {
                        try
                        {
                            context.PushServiceType(parameter.ParameterType);

                            Logger.Log(
                                LogEventType.FetchDependency, 
                                "impl. type", 
                                registration.ImplType, 
                                "dependency type", 
                                parameter.ParameterType,
                                "stack", 
                                context.ResolvingStackToString());

                            object dependency = Chest.Fetch(parameter.ParameterType, context);
                            constructorInjection.SetParameterValue(parameter.Name, dependency);
                            createdDependencies.Add(dependency);
                        }
                        finally
                        {
                            context.PopType();
                        }
                    }
                }
            }

            object instance = constructorInjection.Invoke();
            context.DependencyGraph.AddInstanceToMap(
                instance, 
                registration.RegistrationHandler,
                createdDependencies);
            return instance;
        }

        private static IDictionary<string, object> MergeRegistrationWithCallingArgs(
            IDictionary<string, object> registrationArgs, 
            IDictionary<string, object> callingArgs)
        {
            Dictionary<string, object> args = new Dictionary<string, object>();
            foreach (KeyValuePair<string, object> pair in registrationArgs)
                args[pair.Key] = pair.Value;

            if (callingArgs != null)
            {
                foreach (KeyValuePair<string, object> pair in callingArgs)
                    args[pair.Key] = pair.Value;
            }

            return args;
        }
    }
}