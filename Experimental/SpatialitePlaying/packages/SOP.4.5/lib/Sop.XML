<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sop</name>
    </assembly>
    <members>
        <member name="T:Sop.Utility.GenericLogger">
            <summary>
            Generic logger is used by Transaction Manager in
            logging transaction activities.
            </summary>
        </member>
        <member name="M:Sop.Utility.GenericLogger.#ctor(System.String)">
            <summary>
            Logger Constructor
            </summary>
            <param name="filename">Filename of the log file</param>
        </member>
        <member name="M:Sop.Utility.GenericLogger.Dispose">
            <summary>
            Dispose the Logger
            </summary>
        </member>
        <member name="M:Sop.Utility.GenericLogger.Close">
            <summary>
            Close the log file
            </summary>
        </member>
        <member name="M:Sop.Utility.GenericLogger.Log(System.String,System.Object[])">
            <summary>
            Log a text given Format and Arguments
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:Sop.Utility.GenericLogger.LogLine">
            <summary>
            Log an empty line
            </summary>
        </member>
        <member name="M:Sop.Utility.GenericLogger.LogLine(System.String,System.Object[])">
            <summary>
            Log a line of text
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="F:Sop.Utility.GenericLogger.LogFilename">
            <summary>
            Log filename
            </summary>
        </member>
        <member name="P:Sop.Utility.GenericLogger.DefaultLogDirectory">
            <summary>
            Default Log Directory.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.File.FileSet">
            <summary>
            FileSet is a Collection of File objects.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.File.IFileSet">
            <summary>
            File Set interface
            </summary>
        </member>
        <member name="T:Sop.IFileSet">
            <summary>
            File Set interface extends Client IFileSet to add common
            File management methods.
            </summary>
        </member>
        <member name="T:Sop.Client.IFileSet">
            <summary>
            File Set interface provides API for storing and managing
            File objects in the set.
            </summary>
        </member>
        <member name="M:Sop.Client.IFileSet.Add(Sop.Client.IFile)">
            <summary>
            Add File to the set.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.IFileSet.Add(System.String,System.String)">
            <summary>
            Add File with Name and Filename to the set.
            </summary>
            <param name="name"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.IFileSet.Contains(Sop.Client.IFile)">
            <summary>
            Check whether the set contains File 'f'.
            </summary>
            <param name="f"></param>
            <returns>true if f is found, false otherwise.</returns>
        </member>
        <member name="M:Sop.Client.IFileSet.Contains(System.String)">
            <summary>
            Check whether the file set contains file with a given name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.IFileSet.GetEnumerator">
            <summary>
            Returns File object enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.IFileSet.GetNames">
            <summary>
            Returns list of names of File objects in the set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.IFileSet.Remove(System.String)">
            <summary>
            Remove File with a given name from the set.
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:Sop.Client.IFileSet.AutoDisposeItem">
            <summary>
            true will auto dispose File from memory when it gets removed from MRU cache or
            when it gets removed from FileSet. false otherwise.
            </summary>
        </member>
        <member name="P:Sop.Client.IFileSet.Count">
            <summary>
            Returns count of File objects in the set.
            </summary>
        </member>
        <member name="P:Sop.Client.IFileSet.Item(System.String)">
            <summary>
            Get/Set File object to/from set.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.IFileSet.Add(Sop.IFile)">
            <summary>
            Implement to add a given File to the set.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.IFileSet.Add(System.String,System.String)">
            <summary>
            Implement Add to create a new File with a given name and filename
            and add this new File to the set.
            </summary>
            <param name="name"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.IFileSet.Contains(Sop.IFile)">
            <summary>
            Check whether set contains File 'f'.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.IFileSet.Contains(System.String)">
            <summary>
            Check whether set contains a File with a given name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.IFileSet.Close">
            <summary>
            Implement to close File set.
            </summary>
        </member>
        <member name="M:Sop.IFileSet.Open">
            <summary>
            Implement to open the File Set.
            </summary>
        </member>
        <member name="M:Sop.IFileSet.Flush">
            <summary>
            Implement to save all changes in set.
            </summary>
        </member>
        <member name="P:Sop.IFileSet.Item(System.String)">
            <summary>
            Implement to Get/Set File object to/from set.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.Persistence.IInternalPersistent">
            <summary>
            For internal use only.
            Allows byte level control (via binary writer/reader) of POCO's serialization/deserialization.
            </summary>
        </member>
        <member name="T:Sop.IWithHintSize">
            <summary>
            Interface has HintSize
            </summary>
        </member>
        <member name="P:Sop.IWithHintSize.HintSizeOnDisk">
            <summary>
            Implement to return the size on disk(in bytes) of this object,
            or return 0 and SOP will ignore it.
            </summary>
        </member>
        <member name="M:Sop.Persistence.IInternalPersistent.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Implement to Pack Persisted Data on a byte array for Serialization.
            </summary>
            <param name="parent"> </param>
            <param name="writer"> </param>
            <returns>packed byte array</returns>
        </member>
        <member name="M:Sop.Persistence.IInternalPersistent.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            Given byte array read from stream, read the bytes needed to de-serialize this object by assigning
            to appropriate fields of this object the read data.
            </summary>
            <param name="parent"> </param>
            <param name="reader"> </param>
            <returns>0 if object completely Unpacked or the size of the Data waiting to be read on the stream.</returns>
        </member>
        <member name="P:Sop.Persistence.IInternalPersistent.DiskBuffer">
            <summary>
            Disk I/O Buffer
            </summary>
        </member>
        <member name="P:Sop.Persistence.IInternalPersistent.IsDirty">
            <summary>
            true means this InternalPersistent Object was modified and needing save to disk.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.IFileSet.Add(Sop.OnDisk.File.IFile)">
            <summary>
            Add File to the set
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.IFileSet.Add(System.String,System.String)">
            <summary>
            Add File with Name and Filename to the set.
            </summary>
            <param name="name"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.IFileSet.Contains(Sop.OnDisk.File.IFile)">
            <summary>
            Check whether set contains File "F"
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.IFileSet.MarkNotDirty">
            <summary>
            Mark File set not dirty
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFileSet.Item(System.String)">
            <summary>
            Get/Set File object to/from set
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.OnDisk.File.IInternalFileEntity">
            <summary>
            Internal File Entity
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.IInternalFileEntity.CloseStream">
            <summary>
            Close the File stream
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.IInternalFileEntity.OpenStream">
            <summary>
            Open the File stream
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.#ctor(Sop.OnDisk.File.IFile)">
            <summary>
            Constructor expecting File parameter
            </summary>
            <param name="f"></param>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Open">
            <summary>
            Open the File Set
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Dispose">
            <summary>
            Dispose from Memory the FileSet
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Close">
            <summary>
            Close the FileSet
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Flush">
            <summary>
            Save the changes on the File set
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Serialize
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            DeSerialize
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.GetNames">
            <summary>
            Returns list of Names of Files in this FileSet
            </summary>
            <returns>Array of Names</returns>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.GetEnumerator">
            <summary>
            Returns an enumerator for all the File objects in this FileSet
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Add(System.String,System.String)">
            <summary>
            Add a File object to the Set
            </summary>
            <param name="name">Name of File Object</param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Add(Sop.OnDisk.File.IFile)">
            <summary>
            Add a File object to the Set
            </summary>
            <param name="f"></param>
            <param name="f"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Remove(System.String)">
            <summary>
            Remove the File with a given Name from the Set
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Sop.OnDisk.File.FileSet.Remove(System.String,System.Boolean)">
            <summary>
            Remove the File with a given Name from the Set and optionally
            delete it from the file system
            </summary>
            <param name="name"></param>
            <param name="deleteFile"></param>
        </member>
        <member name="P:Sop.OnDisk.File.FileSet.Count">
            <summary>
            Returns count of Files in this FileSet
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.FileSet.HintSizeOnDisk">
            <summary>
            Return the size on disk(in bytes) of this object
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.FileSet.Item(System.String)">
            <summary>
            Searches files in set for the one having its File Name equal to Name parameter.
            </summary>
            <param name="name"> </param>
            <returns></returns>
        </member>
        <member name="P:Sop.OnDisk.File.FileSet.DiskBuffer">
            <summary>
            get/set the DiskBuffer of this FileSet
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.FileSet.IsDirty">
            <summary>
            get/set whether this FileSet was modified or not
            </summary>
        </member>
        <member name="T:Sop.OnDisk.File.File">
            <summary>
            File object. A File can have one or more Collections On Disk.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.File.IFile">
            <summary>
            SOP File interface
            </summary>
        </member>
        <member name="T:Sop.IFile">
            <summary>
            SOP File interface extends the Client IFile adding basic I/O methods.
            </summary>
        </member>
        <member name="T:Sop.Client.IFile">
            <summary>
            SOP File interface.
            A File is a container of objects including Collections on disk.
            </summary>
        </member>
        <member name="M:Sop.Client.IFile.GetSegmentSize">
            <summary>
            Returns the File's data segment size.
            Each collection on disk that belongs to a file has the same data segment size and they
            grow or expand the file by this amount when space is needed to store more data.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.IFile.Rename(System.String)">
            <summary>
            Rename the File.
            </summary>
            <param name="newName"></param>
        </member>
        <member name="P:Sop.Client.IFile.DataBlockSize">
            <summary>
            Returns the size of a Data Block
            </summary>
        </member>
        <member name="P:Sop.Client.IFile.Filename">
            <summary>
            Returns physical filename of the File object.
            </summary>
        </member>
        <member name="P:Sop.Client.IFile.Name">
            <summary>
            Returns the name of the File Object as it is registered in Object Server's FileSet
            collection.
            </summary>
        </member>
        <member name="P:Sop.Client.IFile.Encoding">
            <summary>
            Returns the character Encoding used during serialization/deserialization to/from file.
            </summary>
        </member>
        <member name="P:Sop.Client.IFile.Store">
            <summary>
            Object Store is a Collection on disk that provides
            high speed and scalable item storage, access and manageability.
            </summary>
        </member>
        <member name="P:Sop.Client.IFile.Profile">
            <summary>
            Returns the File Profile.
            </summary>
        </member>
        <member name="P:Sop.Client.IFile.Server">
            <summary>
            Object Server this File belongs.
            </summary>
        </member>
        <member name="M:Sop.IFile.Open">
            <summary>
            Implement to open the File.
            </summary>
        </member>
        <member name="M:Sop.IFile.Close">
            <summary>
            Implement to close the File.
            </summary>
        </member>
        <member name="M:Sop.IFile.Flush">
            <summary>
            Implement to save to disk all modified POCOs (in-memory) of each Store of the File.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.File.IFileEntity">
            <summary>
            File Entity Interface
            </summary>
        </member>
        <member name="T:Sop.OnDisk.File.IEntity">
            <summary>
            Entity interface
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IEntity.IsNew">
            <summary>
            true means this entity is new, otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IEntity.Name">
            <summary>
            Name of the entity
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.IFileEntity.Open">
            <summary>
            Open the File Entity
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.IFileEntity.Close">
            <summary>
            Close the File Entity
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.IFileEntity.Flush">
            <summary>
            Save this file entity
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFileEntity.IsOpen">
            <summary>
            File Entity is Open(true) or not
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.IFile.CreateLookupTable">
            <summary>
            Create Lookup Table
            For Internal use.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.IFile.CreateLookupTable(Sop.Persistence.IInternalPersistent)">
            <summary>
            Create Lookup Table
            For Internal use.
            </summary>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.IFile.GetParent(System.Type)">
            <summary>
            Retrieves a Parent of a specific Type.
            For Internal use.
            </summary>
            <param name="parentType"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.IFile.Initialize(Sop.OnDisk.ObjectServer,System.String,System.String,Sop.OnDisk.IO.AccessMode,Sop.Profile)">
            <summary>
            Initialize the File
            </summary>
            <param name="server"></param>
            <param name="name"></param>
            <param name="filename"></param>
            <param name="accessMode"></param>
            <param name="profile"></param>
        </member>
        <member name="M:Sop.OnDisk.File.IFile.ToString">
            <summary>
            Save the changes to the File
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.IFile.UnbufferedOpen(System.Int32@)">
            <summary>
            Unbuffered open a file
            </summary>
            <param name="systemBlockSize"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.IFile.MarkNotDirty">
            <summary>
            Mark not dirty.
            For Internal use
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.IFile.RemoveFromPool(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            For Internal use
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Sop.OnDisk.File.IFile.AddToPool(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            For Internal use
            </summary>
            <param name="collection"></param>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.CollectionGrowthSizeInNob">
            <summary>
            Collection Growth Size in Number of Blocks
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.DefaultFileStream">
            <summary>
            Returns the Default File Stream.
            NOTE: the ObjectStore's FileStream is the default FileStream
            of the File Object
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.Store">
            <summary>
            Returns the single ObjectStore of the File Object.
            NOTE: ObjectStore can store diverse kinds of Items (key/value pairs).
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.Transaction">
            <summary>
            Returns the Transaction Root this File belongs to
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.MruMinCapacity">
            <summary>
            MRU Minimum Capacity
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.MruMaxCapacity">
            <summary>
            MRU Maximum Capacity
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.DeletedCollections">
            <summary>
            DeletedCollections is the container of all deleted Collections
            within the File Object
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.Server">
            <summary>
            Object Server this File is a member of its FileSet
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.CollectionCounter">
            <summary>
            For Internal use
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.IFile.Size">
            <summary>
            For Internal use
            </summary>
        </member>
        <member name="F:Sop.OnDisk.File.File.mruMinCapacity">
            <summary>
            MRU Minimum capacity for Store of this file.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.File.File.mruMaxCapacity">
            <summary>
            MRU Maximum capacity for Store of this file.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.File.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.File.#ctor(Sop.OnDisk.ObjectServer,System.String,System.String,Sop.OnDisk.IO.AccessMode,Sop.Profile)">
            <summary>
            Constructor
            </summary>
            <param name="server"></param>
            <param name="name"> </param>
            <param name="filename"></param>
            <param name="accessMode"></param>
            <param name="profile"></param>
        </member>
        <member name="M:Sop.OnDisk.File.File.GetSegmentSize">
            <summary>
            Returns the _region Size on disk of the File
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.File.CreateLookupTable">
            <summary>
            Create a Lookup Table
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.File.CreateLookupTable(Sop.Persistence.IInternalPersistent)">
            <summary>
            Create a Lookup table
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.File.Initialize(Sop.OnDisk.ObjectServer,System.String,System.String,Sop.OnDisk.IO.AccessMode,Sop.Profile)">
            <summary>
            Initialize this File
            </summary>
            <param name="server"></param>
            <param name="name">Name of the File Object</param>
            <param name="filename"></param>
            <param name="accessMode"></param>
            <param name="profile"></param>
        </member>
        <member name="M:Sop.OnDisk.File.File.Dispose">
            <summary>
            Dispose this File from Memory
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.File.Grow(System.Int64@)">
            <summary>
            Grow will expand the file to create space for new blocks' allocation.
            </summary>
            <param name="startOfGrowthBlocks"></param>
            <returns>Growth _region Size in bytes</returns>
        </member>
        <member name="M:Sop.OnDisk.File.File.Open(System.String,Sop.OnDisk.IO.AccessMode)">
            <summary>
            Open the file.
            </summary>
            <param name="filename">name of file to open</param>
            <param name="accessMode">AccessMode's are Read Only, Read/Write</param>
        </member>
        <member name="M:Sop.OnDisk.File.File.Open">
            <summary>
            Open the File
            </summary>
        </member>
        <member name="F:Sop.OnDisk.File.File._fileBlockSize">
            <summary>
            Default File Data Block size is 512 bytes
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.File.UnbufferedOpen(System.String)">
            <summary>
            Open a File with buffering disabled
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.File.UnbufferedOpen(System.String,System.Int32@)">
            <summary>
            Open a File with buffering disabled
            </summary>
            <param name="filename"></param>
            <param name="blockSize"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.File.UnbufferedOpen(System.String,System.IO.FileAccess,System.Int32,System.Int32@)">
            <summary>
            Open a File with buffering disabled.
            NOTE: BTree Gold needs to provide its own buffering for performance.
            </summary>
            <param name="bufferSize"> </param>
            <param name="blockSize"></param>
            <param name="filename"> </param>
            <param name="accessMode"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.File.UnbufferedOpen(System.Int32@)">
            <summary>
            Open a File with buffering disabled.
            NOTE: BTree Gold needs to provide its own buffering for performance.
            </summary>
            <param name="systemBlockSize"> </param>
            <returns></returns>
        </member>
        <member name="F:Sop.OnDisk.File.File._blockSize">
            <summary>
            Block Size
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.File.Flush">
            <summary>
            Save ObjectStores of this File Object
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.File.MarkNotDirty">
            <summary>
            For SOP internal use
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.File.Close">
            <summary>
            Close the file
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.File.ToString">
            <summary>
            Returns Name of this instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.File.File.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Pack this File object
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.File.File.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            Unpack this object
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="M:Sop.OnDisk.File.File.GetParent(System.Type)">
            <summary>
            Returns the Parent of this File
            </summary>
            <param name="parentType"></param>
            <returns></returns>
        </member>
        <member name="F:Sop.OnDisk.File.File.Parent">
            <summary>
            Parent of a File is a Collection. e.g. - FileSet is a specialized Collection.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.File.File._store">
            <summary>
            Object Store
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.File.AddToPool(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            Add Collection to the Collections' Pool
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Sop.OnDisk.File.File.RemoveFromPool(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            Remove the Collection from Collections' Pool
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Sop.OnDisk.File.File.Rename(System.String)">
            <summary>
            Rename this File
            </summary>
            <param name="newName"></param>
        </member>
        <member name="F:Sop.OnDisk.File.File.CollectionsPool">
            <summary>
            Collections' Pool is a dictionary.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.DataBlockSize">
            <summary>
            Returns the Sop.DataBlock Size of the File
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.IsDirty">
            <summary>
            IsDirty tells BTree whether this object needs to be rewritten to disk(dirty) or not
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.MruMinCapacity">
            <summary>
            MRU Minimum Capacity
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.MruMaxCapacity">
            <summary>
            MRU Maximum Capacity
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.Transaction">
            <summary>
            Returns the Transaction this File object belongs to
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.Filename">
            <summary>
            Name of the file where Collections of this File Objects
            store/read data.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.DefaultFileStream">
            <summary>
            Default FileStream is the File's ObjectStore's FileStream
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.Name">
            <summary>
            Returns Name of this File Entity
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.Size">
            <summary>
            Size of the File
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.CollectionGrowthSizeInNob">
            <summary>
            Growth Size in Number of Blocks
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.AccessMode">
            <summary>
            AccessMode defaults to Read Write
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.DeletedCollections">
            <summary>
            Deleted Collections are recycled and reused using methods of this Collection.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.Profile">
            <summary>
            Contains B-Tree profile for this file object
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.Store">
            <summary>
            ObjectStore provides storage management and retrieval for persisted Objects.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.Server">
            <summary>
            Object Server
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.HintSizeOnDisk">
            <summary>
            Return the size on disk(in bytes) of this object
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.IsNew">
            <summary>
            true means File is new, otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.File.IsOpen">
            <summary>
            true if File is open, else false
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk">
            <summary>
            Virtual Collection is the base class of all collections on disk in SOP
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk">
            <summary>
            Collection On Disk interface
            </summary>
        </member>
        <member name="T:Sop.ICollectionOnDisk">
            <summary>
            Collection On Disk interface.
            </summary>
        </member>
        <member name="T:Sop.IBasicIO">
            <summary>
            Basic I/O interface.
            </summary>
        </member>
        <member name="T:Sop.Client.IItemNavigation">
            <summary>
            Item navigation interface.
            </summary>
        </member>
        <member name="M:Sop.Client.IItemNavigation.MoveFirst">
            <summary>
            Move pointer to first entry in the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.IItemNavigation.MoveNext">
            <summary>
            Advance the pointer to the next entry in the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.IItemNavigation.MovePrevious">
            <summary>
            Backtracks the pointer to the previous entry in the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.IItemNavigation.MoveLast">
            <summary>
            Move pointer to last entry in the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.IBasicIO.Open">
            <summary>
            Open the Object Store/File.
            </summary>
        </member>
        <member name="M:Sop.IBasicIO.Flush">
            <summary>
            Flush to disk all modified POCOs in-memory.
            </summary>
        </member>
        <member name="M:Sop.ICollectionOnDisk.Close">
            <summary>
            Close the collection
            </summary>
        </member>
        <member name="P:Sop.ICollectionOnDisk.Name">
            <summary>
            Get/Set the name of the Collection On Disk Instance
            </summary>
        </member>
        <member name="P:Sop.ICollectionOnDisk.File">
            <summary>
            File getter returns the File container
            </summary>
        </member>
        <member name="P:Sop.ICollectionOnDisk.IsOpen">
            <summary>
            true if this Collection On Disk is open, otherwise false.
            </summary>
        </member>
        <member name="P:Sop.ICollectionOnDisk.InMemoryId">
            <summary>
            Returns in-memory ID of this collection.
            </summary>
        </member>
        <member name="P:Sop.ICollectionOnDisk.Transaction">
            <summary>
            Transaction
            </summary>
        </member>
        <member name="P:Sop.ICollectionOnDisk.DataBlockSize">
            <summary>
            Sop.DataBlock Size
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.Collection.ICollectionCache">
            <summary>
            Collection Cache interface.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionCache.MruManager">
            <summary>
            Objects MRU cache manager.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionCache.Blocks">
            <summary>
            Data Blocks cache.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.RegisterChange(System.Boolean)">
            <summary>
            Register the change(s) done. e.g. - after add/update/remove of an object,
            the code needs to call Collection On Disk's "RegisterChange" function.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.Load">
            <summary>
            Load the collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.OnCommit">
            <summary>
            Internal use only: OnCommit is invoked to allow some Collection state to be finalized during commit phase
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.OnRollback">
            <summary>
            Internal use only: OnRollback is invoked to allow Collection to undo some state during rollback phase
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.MoveTo(System.Int64)">
            <summary>
            Move file pointer to a disk offset specified by Address
            </summary>
            <param name="dataAddress"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.OnMaxCapacity(System.Int32)">
            <summary>
            On Max Capacity handler method
            </summary>
            <param name="countOfBlocksUnloadToDisk"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.GetParent(System.Type)">
            <summary>
            Traverse the Parent hierarchy and look for a Parent of a given Type.
            Example, one can look for the "File" container of a Collection or a Parent
            Collection of a Collection and so on and so forth..
            </summary>
            <param name="parentType"> </param>
            <returns></returns>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.IsValueInStream">
            <summary>
            Returns true if Value was not loaded using known Serialization techniques
            and is awaiting custom DeSerialization by your code
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.IsTransactionStore">
            <summary>
            Is Collection a transaction store or not.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.StreamReader">
            <summary>
            Returns the Collection's Stream Reader
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.File">
            <summary>
            File getter returns the File container
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.Transaction">
            <summary>
            Transaction Logger
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.IsUnloading">
            <summary>
            For internal use: true means collection is Unloading, otherwise false.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.IsCloned">
            <summary>
            For internal use: true means collection was a product of cloning, otherwise false.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.FileStream">
            <summary>
            FileStream used in reading data from file. Write is done via BulkWriter which uses
            its own set of FileStreams.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.CurrentEntry">
            <summary>
            Returns the Current entry
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.CurrentEntryDataAddress">
            <summary>
            Address on disk of current entry's data
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk.Parent">
            <summary>
            Parent of this object can be another Collection or File object.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.IInternalPersistentRef">
            <summary>
            InternalPersistent Object Reference interface
            </summary>
        </member>
        <member name="P:Sop.OnDisk.IInternalPersistentRef.DataAddress">
            <summary>
            DataAddress
            </summary>
        </member>
        <member name="P:Sop.OnDisk.IInternalPersistentRef.MruManager">
            <summary>
            MRU cache manager
            </summary>
        </member>
        <member name="T:Sop.Mru.IMruClient">
            <summary>
            MRU Client interface
            </summary>
        </member>
        <member name="M:Sop.Mru.IMruClient.OnMaxCapacity(System.Collections.IEnumerable)">
            <summary>
            OnMaxCapacity will be invoked when MRU reached maximum count of items
            and removing some of them for persistence/swap to more permanent
            store like disk.
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Sop.Mru.IMruClient.OnMaxCapacity">
            <summary>
            OnMaxCapacity will be invoked when MRU reached maximum capacity
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetCurrentDataBlock(System.Boolean)">
            <summary>
            Returns the Current Sop.DataBlock with option not to put it on cache
            </summary>
            <param name="getForRemoval"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Open">
            <summary>
            Open the Collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Close">
            <summary>
            Close the Collection
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Delete" -->
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Clear">
            <summary>
            Clear contents of this Collection.
            Changes will be saved right after clearing the contents.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetParent(System.Type)">
            <summary>
            Traverse the Parent hierarchy and look for a Parent of a given Type.
            Example, one can look for the "File" container of a Collection or a Parent
            Collection of a Collection and so on and so forth..
            </summary>
            <param name="parentType"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetTopParent">
            <summary>
            Returns the topmost parent
            </summary>
            <returns></returns>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.OnDiskBinaryWriter">
            <summary>
            OnDiskBinaryWriter is used for persisting Data values to target
            Data Block
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.OnDiskBinaryReader">
            <summary>
            OnDiskBinaryReader is used for Reading Data value from target
            Data Block
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Serialize this Collection meta info
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            DeSerialize this Collection's Meta Info
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Load">
            <summary>
            Reads into memory the Collection On Disk's Header Block which contains
            state information of the collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.ToString">
            <summary>
            Override ToString to return the Name of the Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Flush">
            <summary>
            Flush all "modified" data blocks in cache onto Disk.
            NOTE: cache fault event will also cause modified data blocks 
            to be saved to disk and Save will only save those "modified ones" 
            that didn't get evicted from cache during said event.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.RegisterChange(System.Boolean)">
            <summary>
            Register current collection's state
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetDeletedBlock(System.Int32,System.Boolean,System.Boolean@)">
            <summary>
            Get a deleted block from Collection 'block recycle bin' or from File 'collection recycle bin'.
            </summary>
            <param name="requestedBlockSize"> </param>
            <param name="isCollectionBlock"> </param>
            <param name="collectionDeletedBlock"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.#ctor(Sop.OnDisk.File.IFile)">
            <summary>
            Constructor
            </summary>
            <param name="file"></param>
            <param name="dataBlocksMruManager"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.MoveFirst">
            <summary>
            Move current item pointer to 1st item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.MoveNext">
            <summary>
            Move current item pointer to next item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.MovePrevious">
            <summary>
            Move current item pointer to previous item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.MoveLast">
            <summary>
            Move current item pointer to last item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.MoveTo(System.Int64)">
            <summary>
            Move current item pointer to a specific item
            </summary>
            <param name="dataAddress">Address of item</param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.InternalDispose">
            <summary>
            protected virtual dispose.
            Closes this Collection on disk, its deleted blocks and Mru Segments.
            Sets the data block driver to null.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Dispose">
            <summary>
            Dispose from memory this collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.AddToBlocks(Sop.DataBlock,System.Collections.Generic.IDictionary{System.Int64,Sop.DataBlock})">
            <summary>
            Add to target block collection a certain Block
            </summary>
            <param name="blockSource"></param>
            <param name="blocksDest"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.OnRead(System.Int64)">
            <summary>
            OnRead gets called to read Object from Disk
            </summary>
            <param name="address">Address of Object on disk</param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.OnMaxCapacity(System.Int32)">
            <summary>
            When maximum capacity of DataBlocks' MRU Manager is reached, 
            it calls this version of "OnMaxCapacity" in order to 
            reduce the number of objects kept in-memory
            </summary>
            <param name="countOfBlocksUnloadToDisk">Recommended number of objects for removal</param>
            <returns>Actual Number of objects removed from memory</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.OnMaxCapacity(System.Collections.IEnumerable)">
            <summary>
            When maximum capacity of Collection's Objects' MRU Manager is reached, 
            it calls this version of "OnMaxCapacity" in order to 
            reduce the number of objects kept in-memory
            </summary>
            <param name="nodes">List of Collection Objects or "Nodes" that were removed
            from memory and should be saved to disk</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.OnMaxCapacity">
            <summary>
            On Max Capacity
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.WriteToDisk(Sop.Persistence.IInternalPersistent,System.Boolean)">
            <summary>
            Serialize object and write its byte array to disk
            </summary>
            <param name="value"></param>
            <param name="isCollectionBlock"> </param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.WriteToBlock(System.Object,Sop.DataBlock)">
            <summary>
            Serialize Object to destination block
            </summary>
            <param name="value">Object to Serialize</param>
            <param name="destination">Target Block</param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.WriteToBlock(System.Object,Sop.DataBlock,System.Boolean)">
            <summary>
            Write Value to the Sop.DataBlock.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Grow(System.Int64@)">
            <summary>
            Grow will expand the file to create space for new blocks' allocation.
            </summary>
            <param name="startOfGrowthBlocks"></param>
            <returns>Growth _region Size in bytes</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Initialize(Sop.OnDisk.File.IFile,System.String,System.Collections.Generic.KeyValuePair{System.String,System.Object}[])">
            <summary>
            Initialize.
            </summary>
            <param name="file"></param>
            <param name="dataBlocksMruManager"></param>
            <param name="name"></param>
            <param name="extraParams"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Initialize(Sop.OnDisk.File.IFile,System.Collections.Generic.KeyValuePair{System.String,System.Object}[])">
            <summary>
            Initialize. NOTE: this function doesn't open the file.
            </summary>
            <param name="file"></param>
            <param name="parameters"> </param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetParamValue(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.String)">
            <summary>
            Retrieve Parameter Value from Parameter list
            </summary>
            <param name="parameters"></param>
            <param name="paramName">Name of Parameter to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetSize(System.IO.BinaryReader)">
            <summary>
            Retrieves from the stream the size of the object to be DeSerialized
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.ReadFromBlock(Sop.DataBlock,System.Object)">
            <summary>
            Read or DeSerialize Object from its Source Sop.DataBlock
            </summary>
            <param name="source"></param>
            <param name="target">Destination of Object DeSerialization</param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.WriteToBlock(System.Object)">
            <summary>
            Write Value to the Sop.DataBlock
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetId">
            <summary>
            Returns the Data Address on disk(or virtual data store) of this Collection
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.SetId(System.Int64)">
            <summary>
            Update the Data Address of this Collection on disk
            </summary>
            <param name="address"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetIsDirty(Sop.DataBlock)">
            <summary>
            Returns flag that tells whether this Collection had been modified or not
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.SetIsDirty(Sop.DataBlock,System.Boolean)">
            <summary>
            Mark this Collection as modified or not
            </summary>
            <param name="block"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetId(Sop.DataBlock)">
            <summary>
            Returns the ID(DataAddress if block is not virtualized block) of a given block
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.SetId(Sop.DataBlock,System.Int64)">
            <summary>
            Set Block ID to a given Address
            </summary>
            <param name="block"></param>
            <param name="address"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.SetId(Sop.DataBlock,Sop.DataBlock)">
            <summary>
            Set Target Block Dest ID with ID of Source block
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.GetCurrentDataBlock">
            <summary>
            Returns the Current Sop.DataBlock
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.RemoveFromCache(Sop.Transaction.ITransactionLogger)">
            <summary>
            Remove the Object with "Address" from Object and Sop.DataBlock MRUs.
            </summary>
            <param name="transaction"> </param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.RemoveInMemory(System.Int64,Sop.Transaction.ITransactionLogger)">
            <summary>
            Remove from in-memory blocks the block referenced
            by DataAddress.
            NOTE: this function is invoked when Rolling back changes
            </summary>
            <param name="dataAddress"></param>
            <param name="transaction"> </param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.IsSimpleType(System.Object)">
            <summary>
            Check whether a given object 'o' is of SOP simple type.
            SOP simple types are:
                float, short/ushort, double, bool, byte/sbyte/char, decimal, int/uint, long/ulong, datetime
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.IsSimpleType(System.Type)">
            <summary>
            Check whether a given type 't' is an SOP simple type.
            SOP simple types are:
                float, short/ushort, double, bool, byte/sbyte/char, decimal, int/uint, long/ulong, datetime
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.ReadPersistentData(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader,System.Object@,Sop.Collections.BTree.ItemType)">
            <summary>
            Read/Deserialize Persisted object
            </summary>
            <param name="parent"> </param>
            <param name="reader"></param>
            <param name="itemType"> </param>
            <param name="deSerializedObject">DeSerializedObject will contain the Deserialized object (returns true), 
            else the size of the Custom Persisted object (returns false).
            </param>
            <returns>true if Deserialized, 
                    false if End of Stream,
                    null if object was Custom Persisted and was not read</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.WritePersistentData(Sop.Persistence.IInternalPersistent,System.Object,System.IO.BinaryWriter,Sop.Collections.BTree.ItemType)">
            <summary>
            Serialize Object in preparation for saving to disk/virtual store
            </summary>
            <param name="parent"></param>
            <param name="objectToSerialize"></param>
            <param name="writer"></param>
            <param name="itemType"> </param>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.CurrentEntryDataAddress">
            <summary>
            Address on disk of current entry's data
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.CurrentDataBlock">
            <summary>
            Returns the Current Sop.DataBlock
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.FileStream">
            <summary>
            get/set Collection's FileStream
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.IsOpen">
            <summary>
            Returns true if this Collection is open, otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Parent">
            <summary>
            Parent of this object can be another Collection or File object.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.IsValueInStream">
            <summary>
            Returns true if Value is in Binary Reader Stream (OnDiskBinaryReader),
            otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Count">
            <summary>
            Returns the Count of Items in the Collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.HintSizeOnDisk">
            <summary>
            Return the size on disk(in bytes) of this object
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.MruManager">
            <summary>
            Objects MRU cache manager
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.ChangeRegistry">
            <summary>
            ChangeRegistry - true will enable registry of changes to collection,
            false will disable.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Transaction">
            <summary>
            Transaction log
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.DataAddress">
            <summary>
            Address of this Collection on disk or on virtual store
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.DiskBuffer">
            <summary>
            Default implementation is to retrieve the disk buffer from MRU,
            override if needed to read/save data from/to Disk if not in MRU
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.DataBlockSize">
            <summary>
            Sop.DataBlock Size
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.DeletedBlocks">
            <summary>
            Deleted blocks maintains list of all deleted blocks on this Collection.
            Deleted blocks are tracked for recycling.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.IsDeletedBlocksList">
            <summary>
            true means this Collection is the DeletedBlocksList (a.k.a. - the recycle bin).
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.IsTransactionStore">
            <summary>
            true means this CollectionOnDisk is a Transaction Store.
            NOTE: Transaction Stores are handled differently than
            normal Collections within a Transaction.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.ParentTransactionLogger">
            <summary>
            INTERNAL USE ONLY. Parent Transaction Logger
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.StreamReader">
            <summary>
            Collection Default Stream Reader
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.IsDirty">
            <summary>
            IsDirty tells BTree whether this object needs to be rewritten to disk(dirty) or not
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.IsNew">
            <summary>
            true means File Entity is new, otherwise false
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.MruMinCapacity" -->
        <!-- Badly formed XML comment ignored for member "P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.MruMaxCapacity" -->
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Blocks">
            <summary>
            Data Blocks cache.
            Set of Blocks for write to Disk. An Object is serialized
            into a series of Data Blocks which get written to Disk.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.Name">
            <summary>
            Name of the Collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.HeaderData">
            <summary>
            HeaderData contains the Collection's Block Allocation Table(BAT) information
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.DataBlockDriver">
            <summary>
            get/set Sop.DataBlock Driver used by this Collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.File">
            <summary>
            Returns the File interface
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.CurrentEntry">
            <summary>
            Returns the Current entry DeSerialized from File Stream.
            Will return:
            - byte[] if IInternalPersistent was saved
            - DeSerialized Value if object was Serialized
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.Collection.CollectionOnDisk.InMemoryId">
            <summary>
            Returns in-memory ID of this collection.
            </summary>
        </member>
        <member name="T:Sop.IProxyObject">
            <summary>
            SOP's virtual Proxy Object is a wrapper class for containing actual object
            reference to any object proxied by the instance.
            </summary>
        </member>
        <member name="T:Sop.IProxyObject`1">
            <summary>
            Generic version of the SOP virtual Proxy Object wrapper class.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Sop.IProxyObject`1.RealObject">
            <summary>
            Contains reference to the real object this proxy is a wrapper of.
            NOTE: this is for SOP internal framework use only.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm">
            <summary>
            B-Tree Algorithm collection class
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.IBTreeAlgorithm">
            <summary>
            BTree Algorithm interface.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.DefaultSlotLength">
            <summary>
            B-Tree default number of slots
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Open">
            <summary>
            Open the collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Flush">
            <summary>
            Save the modified nodes/items to disk/virtual store.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Add(Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk)" -->
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Remove(System.Object)">
            <summary>
            Remove item from B-Tree.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Remove(System.Object,System.Boolean)">
            <summary>
            Remove "Item" from the tree. Doesn't throw exception if "Item" is not found
            </summary>
            <param name="item">Record to remove</param>
            <param name="removeAllOccurrence"> </param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Remove(Sop.QueryExpression[],System.Boolean,Sop.QueryResult[]@)">
            <summary>
            
            </summary>
            <param name="items"> </param>
            <param name="removeAllOccurrence"></param>
            <param name="results"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Search(System.Object)">
            <summary>
            Search for Item in this collection
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Search(System.Object,System.Boolean)">
            <summary>
            Search for Item in this collection with an option
            to position the B-Tree current pointer to the 1st
            instance of the record having matching key with 'Item'.
            This is useful when searching a tree with items having
            duplicate Keys.
            </summary>
            <param name="item"></param>
            <param name="goToFirstInstance"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Close">
            <summary>
            Close the collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Clear">
            <summary>
            Clear all items of the Collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Delete">
            <summary>
            Recycle DataSet, KeySet and DeletedBlocks' Segments
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.MoveFirst">
            <summary>
            Move current item pointer to the 1st item of the tree
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.MovePrevious">
            <summary>
            Move current item pointer to the previous item relative to the
            current item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.MoveNext">
            <summary>
            Move current item pointer to next item relative to the current item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.MoveLast">
            <summary>
            Move current item pointer to the last item of the tree
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Initialize(Sop.OnDisk.File.IFile,System.Collections.Generic.KeyValuePair{System.String,System.Object}[])">
            <summary>
            Initialize the tree's members preparing for use.
            </summary>
            <param name="file"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.GetDiskBlock(Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk,System.Int64)">
            <summary>
            Read the Block with 'ID' from disk or virtual source.
            </summary>
            <param name="dataSet"> </param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.OnRead(System.Int64)">
            <summary>
            Calls GetDiskBlock for reading the Block to memory,
            add block to cache, and mark the items for load from disk upon access
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.SaveBlocks(System.Boolean)">
            <summary>
            Save the serialized data on blocks to disk
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.IsRoot(System.Int64)">
            <summary>
            Tells whether Address references the Root Node
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.IsRoot(Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk)">
            <summary>
            Tells whether Node is a Root Node
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.OnMaxCapacity(System.Int32)">
            <summary>
            Gets invoked when MRU Maximum capacity of the tree is reached and 
            offloads to disk the least used data blocks in MRU
            </summary>
            <param name="countOfBlocksUnloadToDisk"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.SetDiskBlock(Sop.DataBlock)">
            <summary>
            Assign an Address or ID to the disk block if DataAddress == 1.
            NOTE to Implementors: SetDiskBlock will be invoked even if DataAddress or ID had already been set,
            so you need to assign a new ID or Address only if the said field is -1.
            </summary>
            <param name="headBlock"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.SetDiskBlock(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,Sop.DataBlock)">
            <summary>
            Make DiskBuffer the Parent Collection's DiskBuffer
            </summary>
            <param name="parent"></param>
            <param name="diskBuffer"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Remove">
            <summary>
            Delete the current item from the tree. Tree is maintained to be balanced and sorted.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.OnMaxCapacity">
            <summary>
            MRU on max capacity overload. This version is invoked during Low RAM
            situation and collections are given chance to free up cache to increase
            available RAM once again.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.OnMaxCapacity(System.Collections.IEnumerable)">
            <summary>
            MRU on max capacity overload. This version is invoked in cases code
            knows which set of Nodes can be offloaded from memory
            </summary>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.SaveNode(Sop.Collections.Generic.ISortedDictionary{System.Int64,Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk})">
            <summary>
            Save Nodes to disk/virtual destination
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.SaveNode(Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk,System.Boolean)">
            <summary>
            Save Node to disk/virtual destination
            </summary>
            <param name="node"></param>
            <param name="addToMru">true will add to cache the Node, else will not</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.BeginTreeMaintenance">
            <summary>
            Begin Tree Maintenance mode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.EndTreeMaintenance">
            <summary>
            End Tree Maintenance mode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Query(Sop.QueryExpression[],Sop.QueryResult[]@)">
            <summary>
            Query the B-Tree for each Keys submitted, retrieve their values
            and store them in the array out parameter Values.
            </summary>
            <param name="items"></param>
            <param name="results"></param>
            <returns>true if found at least one key, otherwise false</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Clone">
            <summary>
            Create a shallow copy of this tree for iteration purposes.
            Data on disk are not cloned, 'just a copy of this tree for use
            iteration us created.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.CurrentSequence">
            <summary>
            Returns Current Sequence Number
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.GetNextSequence">
            <summary>
            Go to Next Sequence and return it
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Persist this tree.
            Write to stream the meta information of this tree so
            it can be read back from disk.
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            Load this tree from disk.
            Read from stream the meta information useful for bringing
            back to its previous state in-memory
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.MoveToRootItem">
            <summary>
            Make the root Item the current item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy items, starting from the current item pointer, of this B-Tree to destination array.
            </summary>
            <param name="destArray"></param>
            <param name="startIndex"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.RemoveFromCache(Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk,System.Boolean)">
            <summary>
            Remove Node from Objects' cache
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.RemoveInMemory(System.Int64,Sop.Transaction.ITransactionLogger,System.Boolean)">
            <summary>
            Remove all objects with DataAddress from memory.
            Remove from Data blocks, Objects' cache, collection's Header buffer,...
            </summary>
            <param name="dataAddress"></param>
            <param name="transaction"> </param>
            <param name="reloadIfNotFound"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.UpdateCurrentItem(Sop.DataBlock)">
            <summary>
            Update Currently selected Item of B-Tree.
            This version expects Current Item to be Sop.DataBlock type.
            </summary>
            <param name="source">DataBlock Source</param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.SetCurrentItemAddress(System.Int64,System.Int16)">
            <summary>
            Utility function to assign/replace current item w/ a new item.
            </summary>
            <param name="itemNodeAddress"> </param>
            <param name="itemIndex">slot index of the new item</param>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.CurrentItem">
            <summary>
            This holds the Current Item Address (Current Node and Current Slot index)
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.IsDataLongInt">
            <summary>
            true will save long int data with Key, thus, is a lot more optimized.
            NOTE: you can up-convert short, int to long int to take advantage of 
            this more optimized method.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.AutoDisposeItem">
            <summary>
            true will cause entry's Key and/or Value to be automatically disposed
            when it gets offloaded to disk from memory, false otherwise.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.AutoDispose">
            <summary>
            true will cause this BTreeAlgorithm to be automatically disposed
            when this gets offloaded to disk from memory, false otherwise.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.DataSet">
            <summary>
            Data are stored in DataSet collection.
            DataSet manages storage/retrieval of data in datablocks to/from disk.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.KeySet">
            <summary>
            Key Data are stored on KeySet
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.MaxBlocks">
            <summary>
            Maximum count of blocks to be kept in-memory
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.Comparer">
            <summary>
            Get/Set comparer object used in sorting items of the collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.CurrentValue">
            <summary>
            Current Item's Value getter/setter.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.IsOpen">
            <summary>
            true if collection is open, false otherwise
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.IsDataInKeySegment">
            <summary>
            true means data is saved in Key segment, otherwise on its own segment.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.DataAddress">
            <summary>
            Address on disk/virtual store of this B-Tree
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.RootNode">
            <summary>
            Returns the Root Node of this B-Tree
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.ComparerWrapper">
            <summary>
            comparer wrapper
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.ChangeRegistry">
            <summary>
            get/set the change registry
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.CurrentNode">
            <summary>
            Current Node of the tree
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.CurrentEntry">
            <summary>
            Current Entry (Key and Value pair) of the tree.
            NOTE: current entry is cached so succeeding get will not read from disk or virtual source
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.HintSequentialRead">
            <summary>
            true will allow SOP to optimize reading of the sequential
            records of the B-Tree on disk
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.HintBatchCount">
            <summary>
            Hint Batch Count. When set, B-Tree will
            read ahead this number of records and thus,
            provide a more optimal sequential read access.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.SlotLength">
            <summary>
            Get/Set the tree's Slots' count of items.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.IsDirty">
            <summary>
            get/set whether this tree is modified(dirty) or not
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.IndexBlockSize">
            <summary>
            Data Block size of the index
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.HintKeySizeOnDisk">
            <summary>
            Hint: Key size on disk(in bytes)
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm.HintValueSizeOnDisk">
            <summary>
            Hint: Value size on disk(in bytes)
            </summary>
        </member>
        <member name="T:Sop.Mru.InternalMruManager">
            <summary>
            For MruManager's internal use only.
            </summary>
        </member>
        <member name="F:Sop.Mru.InternalMruManager.GeneratePruneEvent">
            <summary>
            Generate prune event
            </summary>
        </member>
        <member name="T:Sop.Mru.InternalMruManager.Iterator">
            <summary>
            Internal MRU Manager Iterator.
            </summary>
        </member>
        <member name="T:Sop.Transaction.TransactionBase">
            <summary>
            Transaction Base
            </summary>
        </member>
        <member name="T:Sop.Transaction.ITransactionLogger">
            <summary>
            Transaction Logger interface
            </summary>
        </member>
        <member name="T:Sop.ITransaction">
            <summary>
            Transaction interface.
            </summary>
        </member>
        <member name="M:Sop.ITransaction.Begin">
            <summary>
            Begin the transaction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.ITransaction.Commit">
            <summary>
            Commit the transaction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.ITransaction.Rollback">
            <summary>
            Rollback the transaction.
            </summary>
        </member>
        <member name="M:Sop.Transaction.ITransactionLogger.CreateCollection(Sop.IFile,System.Collections.IComparer,System.String,System.Boolean)">
            <summary>
            Create Collection helper method.
            </summary>
            <param name="file"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.ITransactionLogger.Commit(Sop.Transaction.CommitPhase)">
            <summary>
            Commit this Transaction's Children's Transaction(s) then Commit this Transaction.
            </summary>
            <param name="phase"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.ITransactionLogger.InternalCommit(Sop.Transaction.CommitPhase)">
            <summary>
            Implement to Commit this transaction object only.
            NOTE: don't commit children, they are managed by "Commit"
            function, commit just this object.
            </summary>
            <param name="phase"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.ITransactionLogger.GetOuterChild">
            <summary>
            Returns the non-root, transaction logger (TransactionBase class derived).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.ITransactionLogger.InternalRollback(System.Boolean)">
            <summary>
            Implement to Rollback this transaction object only.
            NOTE: don't rollback children, they are managed by "Rollback"
            function, rollback just this object.
            </summary>
        </member>
        <member name="P:Sop.Transaction.ITransactionLogger.IsDisposing">
            <summary>
            true means transaction is in process of being disposed, false otherwise.
            </summary>
        </member>
        <member name="P:Sop.Transaction.ITransactionLogger.Parent">
            <summary>
            Returns the parent Transaction object
            </summary>
        </member>
        <member name="P:Sop.Transaction.ITransactionLogger.Children">
            <summary>
            Nested or Children Transactions 
            </summary>
        </member>
        <member name="P:Sop.Transaction.ITransactionLogger.Root">
            <summary>
            Returns the Root transaction
            </summary>
        </member>
        <member name="P:Sop.Transaction.ITransactionLogger.CurrentCommitPhase">
            <summary>
            Commit Phase
            </summary>
        </member>
        <member name="M:Sop.Transaction.TransactionBase.Dispose">
            <summary>
            Dispose will rollback transaction if isn't in Rollback or Commit state
            </summary>
        </member>
        <member name="M:Sop.Transaction.TransactionBase.Begin">
            <summary>
            Begin a nested Transaction
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.TransactionBase.Begin(System.Boolean)">
            <summary>
            Begin a nested Transaction
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.TransactionBase.Flush">
            <summary>
            Override to Save transaction ObjectStore(s).
            </summary>
        </member>
        <member name="M:Sop.Transaction.TransactionBase.Commit">
            <summary>
            Commit starting Children transaction(s). Rollback if a transaction fails.
            </summary>
        </member>
        <member name="M:Sop.Transaction.TransactionBase.Commit(Sop.Transaction.CommitPhase)">
            <summary>
            Commit starting Children transaction(s)
            </summary>
            <param name="phase"></param>
        </member>
        <member name="M:Sop.Transaction.TransactionBase.Rollback">
            <summary>
            Rollback starting with Children-most transaction(s) then parent
            trans to this trans and its Parent until Root is finally rolled back.
            </summary>
        </member>
        <member name="M:Sop.Transaction.TransactionBase.GetLeafChild">
            <summary>
            Get the 1st element Leafmost Child Transaction
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.TransactionBase.RegisterSave(Sop.OnDisk.Algorithm.Collection.CollectionOnDisk,System.Int64,System.Int32,Sop.OnDisk.IO.ConcurrentIOPoolManager,Sop.OnDisk.IO.ConcurrentIOPoolManager)">
            <summary>
            Try to register block for update and back up contents as needed.
            </summary>
            <param name="collection"></param>
            <param name="blockAddress"></param>
            <param name="segmentSize"></param>
            <param name="readPool"></param>
            <param name="writePool"></param>
            <returns>true means block was registered and contents backed up,
            false means block is either new or recycled and wasn't registered for update and no backup occurred.</returns>
        </member>
        <member name="P:Sop.Transaction.TransactionBase.Id">
            <summary>
            Transaction ID
            </summary>
        </member>
        <member name="P:Sop.Transaction.TransactionBase.CurrentCommitPhase">
            <summary>
            Commit Phase
            </summary>
        </member>
        <member name="P:Sop.Transaction.TransactionBase.Parent">
            <summary>
            Returns Parent Transaction Object
            </summary>
        </member>
        <member name="P:Sop.Transaction.TransactionBase.Children">
            <summary>
            Nested or Children Transactions
            </summary>
        </member>
        <member name="P:Sop.Transaction.TransactionBase.Root">
            <summary>
            Returns the Root transaction
            </summary>
        </member>
        <member name="T:Sop.SpecializedDataStore.PersistentTypeKeySimpleValue`2">
            <summary>
            Sorted Dictionary for IPersistent implementing POCOs.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Sop.SpecializedDataStore.SimpleKeyValue`2">
            <summary>
            Sorted Dictionary for simple value types that stores items to user selected storage medium.
            NOTE: only SOP on Disk is currently supported. Following lists the supported simple types:
            string, byte[], float, short, ushort, double, bool, byte, sbyte, char, decimal, int, uint, long, ulong.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Sop.SpecializedDataStore.SpecializedStoreBase">
            <summary>
            Specialized Store Base.
            </summary>
        </member>
        <member name="M:Sop.SpecializedDataStore.SpecializedStoreBase.FormatStoreName(System.String,System.String)">
            <summary>
            Format Store name using SOP standard method of concatenating
            container with target store's name.
            </summary>
            <param name="containerStoreName"> </param>
            <param name="storeName"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.SpecializedDataStore.SpecializedStoreBase.Collection">
            <summary>
            Returns the internal SortedDictionaryOnDisk type collection that
            actually manages storage/retrieval of data on disk.
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SpecializedStoreBase.UniqueName">
            <summary>
            Returns a globally unique name, e.g. Filename suffix with the Store name.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sop.SpecializedDataStore.SpecializedStoreBase.Locker">
            <summary>
            Locker object provides monitor type(enter/exit) of access locking to the Store.
            </summary>
        </member>
        <member name="T:Sop.ISortedDictionary`2">
            <summary>
            Generic Virtual Sorted Dictionary interface.
            NOTE: SOP virtualizes the Sorted Dictionary between memory and disk.
            All items of the dictionary are stored on disk and mostly used items
            cached in-memory for high speed access.
            
            Keys are allowed to have duplicates.
            Values can be nested Sorted Dictionaries if required.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Sop.Client.ISortedDictionary`2">
            <summary>
            Generics Virtual Sorted Dictionary interface.
            NOTE: SOP virtualizes the Sorted Dictionary between memory and disk.
            All items of the dictionary are stored on disk and mostly used items
            cached in-memory for high speed access.
            
            Keys are allowed to have duplicates.
            Values can be nested Sorted Dictionaries if required.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Sop.Client.ISortedDictionary">
            <summary>
            Non-generics Virtual Sorted Dictionary interface declares
            the methods necessary for implementation of a virtual Sorted Dictionary,
            i.e. - a Sorted Dictionary whose backend data Storage is abstracted
            for its Format(can be SOP, RDBMS,...) and Location(local disk or remote).
            </summary>
        </member>
        <member name="T:Sop.Persistence.IPersistent">
            <summary>
            IPersistent interface to provide
            custom serialization methods for persistence. You can 
            save/read bytes of individual fields to/from persistence stream.
            </summary>
        </member>
        <member name="M:Sop.Persistence.IPersistent.Pack(System.IO.BinaryWriter)">
            <summary>
            Serialize this Object onto the Stream using a Writer.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.Persistence.IPersistent.Unpack(System.IO.BinaryReader)">
            <summary>
            DeSerialize this Object from Stream using a Reader.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="P:Sop.Persistence.IPersistent.IsDisposed">
            <summary>
            Return true if object can be Disposed(is disposed!) and it needs to be reloaded from Disk.
            Return false if your object isn't Disposable and doesn't need to reload from disk.
            
            NOTE: If in Disposed state (true) and it still resides in SOP buffers, next time it 
            gets retrieved from the Container, SOP will reload it from Disk.
            </summary>
        </member>
        <member name="T:Sop.IWithHintBatchAction">
            <summary>
            Interface for defining Hints to optimize batch operations
            </summary>
        </member>
        <member name="P:Sop.IWithHintBatchAction.HintSequentialRead">
            <summary>
            Hint SOP that next operation is a sequential read.
            Hints allow optimization to occur
            </summary>
        </member>
        <member name="P:Sop.IWithHintBatchAction.HintBatchCount">
            <summary>
            Hint that allows code to tell SOP to optimize sequential reading and batch removal of items.
            This Hint tells how many items a batch contains.
            </summary>
        </member>
        <member name="T:Sop.IDeleteable">
            <summary>
            Deleteable interface.
            </summary>
        </member>
        <member name="M:Sop.IDeleteable.Delete">
            <summary>
            Implement to delete Entity from disk.
            </summary>
        </member>
        <member name="P:Sop.Client.ISortedDictionary.AutoDisposeItem">
            <summary>
            Auto Dispose Item when it gets removed from Cache or when it gets deleted
            </summary>
        </member>
        <member name="P:Sop.Client.ISortedDictionary.AutoDispose">
            <summary>
            Auto Dispose this Store when it gets removed from the container's cache.
            </summary>
        </member>
        <member name="P:Sop.Client.ISortedDictionary.IsDataInKeySegment">
            <summary>
            true will store data in the Key region, 
            otherwise data will be stored in the Data region.
            NOTE: if data is small in size, it is recommended to be stored
            in Key region, otherwise in Data region.
            </summary>
        </member>
        <member name="P:Sop.Client.ISortedDictionary.Locker">
            <summary>
            Locker object provides monitor type(enter/exit) of access locking to the Store.
            </summary>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Add a group of items onto the Store.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Clear">
            <summary>
            Removes all items from the Sorted Dictionary.
            NOTE: Clear is synonymous to Delete in this version of SOP.
            </summary>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copy to a target array the contents of the Sorted Dictionary starting from the 1st item.
            When end of dictionary or end of target array is reached, copying will end.
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.EndOfTree">
            <summary>
            Returns true if current record pointer is beyond last item in tree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.GetNextSequence">
            <summary>
            Increment the Sorted Dictionary's Sequence and return its new value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Search(`0,System.Boolean)">
            <summary>
            Search for a Key and allows code to position the record pointer to the
            1st occurrence in the case of Key having duplicates.
            </summary>
            <param name="key"></param>
            <param name="goToFirstOccurrence">true will cause Search to position item pointer to 1st occurrence in the case of duplicated Keys</param>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Search(`0)">
            <summary>
            Search for a Key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Rename(System.String)">
            <summary>
            Rename this Sorted Dictionary
            </summary>
            <param name="newName"></param>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Remove">
            <summary>
            Remove the currently selected Item from the Sorted Dictionary
            </summary>
            <returns>true if there is a selected item and it got deleted, false otherwise</returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Remove(`0,System.Boolean)">
            <summary>
            Remove all occurences of Items with the given Key
            </summary>
            <param name="key"></param>
            <param name="removeAllOccurence"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Remove(Sop.QueryExpression{`0}[],Sop.QueryResult{`0}[]@)">
            <summary>
            Remove Items matching the specified query filter expressions.
            </summary>
            <param name="keyExpressions"></param>
            <param name="results"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Remove(Sop.QueryExpression{`0}[])">
            <summary>
            Remove Items matching the specified query filter expressions.
            </summary>
            <param name="keyExpressions"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Remove(Sop.QueryExpression{`0}[],System.Boolean,Sop.QueryResult{`0}[]@)">
            <summary>
            Remove Items matching the specified query filter expressions.
            </summary>
            <param name="keyExpressions"></param>
            <param name="removeAllOccurence">true will remove all occurences of each Key in Keys</param>
            <param name="results"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Query(Sop.QueryExpression{`0}[],Sop.QueryResult{`0}[]@)">
            <summary>
            Query the B-Tree for each Keys submitted, returns query result
            as array of information containing key, query result, value.
            </summary>
            <param name="keys"></param>
            <param name="results"></param>
            <returns>true if found at least one key, otherwise false</returns>
        </member>
        <member name="M:Sop.Client.ISortedDictionary`2.Update(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Update Items with given Keys
            </summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.Client.ISortedDictionary`2.SortOrder">
            <summary>
            Returns current sort order. Setting to a different sort order will 
            reset BTree. First item according to sort order will be current item.
            </summary>
        </member>
        <member name="P:Sop.Client.ISortedDictionary`2.CurrentKey">
            <summary>
            Returns current item's key
            </summary>
        </member>
        <member name="P:Sop.Client.ISortedDictionary`2.CurrentValue">
            <summary>
            Returns/sets current item's value
            </summary>
        </member>
        <member name="P:Sop.Client.ISortedDictionary`2.Comparer">
            <summary>
            Comparer used to compare Item's Key and provide sorted behavior
            </summary>
        </member>
        <member name="P:Sop.Client.ISortedDictionary`2.CurrentSequence">
            <summary>
            Returns the Current Sequence of the Sorted Dictionary
            </summary>
        </member>
        <member name="P:Sop.Client.ISortedDictionary`2.Name">
            <summary>
            Returns the name of this Sorted Dictionary
            </summary>
        </member>
        <member name="T:Sop.ISortedDictionary">
            <summary>
            Non-generics Virtual Sorted Dictionary interface declares
            the methods necessary for implementation of a virtual Sorted Dictionary,
            i.e. - a Sorted Dictionary whose backend data Storage is abstracted
            for its Format(can be SOP, RDBMS,...) and Location(local disk or remote).
            </summary>
        </member>
        <member name="M:Sop.ISortedDictionary.Flush">
            <summary>
            Flush to disk all modified objects in-memory.
            </summary>
        </member>
        <member name="P:Sop.ISortedDictionary`2.Transaction">
            <summary>
            Transaction this Sorted Dictionary belongs to.
            </summary>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.IsLongCompatible(System.Type)">
            <summary>
            Is Object one of basic types of .net such as the Int family, and the float/double family.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.GetNextSequence">
            <summary>
            Generate a new log sequence and return it
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.ToString">
            <summary>
            Override ToString to return the string value of data address on disk.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Delete">
            <summary>
            Delete from data store this collection and dispose it from memory.
            </summary>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Dispose">
            <summary>
            Dispose the Sorted Dictionary
            </summary>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Flush">
            <summary>
            Save changes to the Sorted Dictionary
            </summary>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Add(`0,`1)">
            <summary>
            Add an item to the dictionary
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.ContainsKey(`0)">
            <summary>
            Checks whether an item with key exists in the Dictionary
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Remove">
            <summary>
            Remove the currently selected Item from the Sorted Dictionary
            </summary>
            <returns>if there is no selected item, returns false, otherwise true</returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Remove(Sop.QueryExpression{`0}[],System.Boolean,Sop.QueryResult{`0}[]@)">
            <summary>
            Remove Items matching the specified query filter expressions.
            </summary>
            <param name="keyExpressions"></param>
            <param name="removeAllOccurence"></param>
            <param name="results"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Remove(`0)">
            <summary>
            Remove Item with key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.TryGetValue(`0,`1@)">
            <summary>
            Retrieve Value if key is in Dictionary, otherwise returns false to imply key not found.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Add Item to the Dictionary
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Clear">
            <summary>
            Clear the Dictionary of all Items.
            NOTE: Clear is synonymous to Delete in this version.
            </summary>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Check for existence of an Item given its Key
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copy to a target array the contents of the Sorted Dictionary starting from the 1st item.
            When end of dictionary or end of target array is reached, copying will end.
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Remove Item from Dictionary
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.MoveNext">
            <summary>
            Move Current Item pointer to next item in Dictionary
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.MovePrevious">
            <summary>
            Move Current Item pointer to previous item in Dictionary
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.MoveFirst">
            <summary>
            Move Current Item pointer to 1st item in Dictionary per its ordering sequence
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.MoveLast">
            <summary>
            Move Current Item pointer to last item in Dictionary per its ordering sequence
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.EndOfTree">
            <summary>
            true if Current Item pointer is beyond last item of the Dictionary, otherwise false
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Query(Sop.QueryExpression{`0}[],Sop.QueryResult{`0}[]@)">
            <summary>
            Query the B-Tree for each Keys submitted, retrieve their values
            and store them in the array out parameter Values.
            </summary>
            <param name="keys">Keys to search for</param>
            <param name="values">null if no Key found, otherwise an array of values in the same order as the submitted keys
            and having the same number of items as the keys. Key(s) not found will have null entries</param>
            <returns>true if found at least one key, otherwise false</returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Search(`0)">
            <summary>
            Search item with Key, passing false to GotoFirstInstance
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.SpecializedDataStore.SimpleKeyValue`2.Search(`0,System.Boolean)">
            <summary>
            Search B-Tree for an item with Key
            </summary>
            <param name="key"></param>
            <param name="goToFirstInstance">Go to 1st key instance if the key has duplicate</param>
            <returns></returns>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.RealObject">
            <summary>
            Return the real object proxied by this wrapper object
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.CurrentSequence">
            <summary>
            Returns the Current Sequence value
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.Name">
            <summary>
            Returns name of the Sorted Dictionary
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.IsDisposed">
            <summary>
            true means this is Disposed, otherwise false
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.Transaction">
            <summary>
            Transaction this object belongs to
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.Keys">
            <summary>
            Returns Collection of Keys for this Dictionary.
            The returned collection is just a wrapper object that
            references the same items' Keys on disk of this Dictionary.
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.Values">
            <summary>
            Returns Collection of Values for this Dictionary.
            The returned collection is just a wrapper object that
            references the same items' Values on disk of this Dictionary.
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.Item(`0)">
            <summary>
            this accessor checks whether key is in dictionary and returns the found item's value,
            otherwise returns null.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.Count">
            <summary>
            Returns count of items of Dictionary
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.SortOrder">
            <summary>
            SortOrder can be ascending or descending
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.CurrentKey">
            <summary>
            Returns Current Item's Key
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.CurrentValue">
            <summary>
            Get/Set Current Item's Value
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.AutoDisposeItem">
            <summary>
            Auto Dispose Item when it gets removed from Cache or when it gets deleted
            </summary>
        </member>
        <member name="P:Sop.SpecializedDataStore.SimpleKeyValue`2.AutoDispose">
            <summary>
            Auto Dispose this Store when it gets removed from the container's cache.
            </summary>
        </member>
        <member name="M:Sop.SpecializedDataStore.PersistentTypeKeySimpleValue`2.GetCollection(Sop.ISortedDictionaryOnDisk,Sop.GenericComparer{`0},System.String,System.Boolean)">
            <summary>
            Override SipleKeyValue GetCollection to add support for IPersistent key/value POCO (de)serialization.
            </summary>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk">
            <summary>
            List On Disk stores and manages a list of objects on Disk
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.MoveNext">
            <summary>
            MoveNext makes the next entry the current one
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.MovePrevious">
            <summary>
            MovePrevious makes the previous entry the current one
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.MoveFirst">
            <summary>
            MoveFirst makes the first entry in the Collection the current one
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.MoveLast">
            <summary>
            MoveLast makes the last entry in the Collection the current one
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.Update(System.Object)">
            <summary>
            Update the data stored at a given Address.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.Update(System.Int64,System.Object)">
            <summary>
            Update the data stored at a given Address.
            </summary>
            <param name="dataAddress"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.PurifyMeta(Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.LinkedItemOnDisk,Sop.DataBlock)">
            <summary>
            Allows child class to purify Meta data from data
            </summary>
            <param name="biod"></param>
            <param name="db"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.Add(System.Object)">
            <summary>
            Add 'Value' to the Collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.Remove">
            <summary>
            Remove current item
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.RemoveAt(System.Int64)">
            <summary>
            Remove ObjectToRemove from the Collection if found, else throws an exception
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.Remove(System.Object)">
            <summary>
            Remove ObjectToRemove from the Collection if found, else throws an exception
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.Clone">
            <summary>
            Shallow copy the Collection into a new instance and return it.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.CurrentEntry">
            <summary>
            Returns the Current entry DeSerialized from File Stream.
            Will return:
            - byte[] if IInternalPersistent was saved
            - DeSerialized Value if object was Serialized
            </summary>
        </member>
        <member name="T:Sop.ItemOnDisk">
            <summary>
            Item On Disk.
            </summary>
        </member>
        <member name="T:Sop.Persistence.InternalPersistent">
            <summary>
            For internal use only. InternalPersistent Object.
            </summary>
        </member>
        <member name="M:Sop.Persistence.InternalPersistent.#ctor(Sop.DataBlockSize)">
            <summary>
            Initialize InternalPersistent Object's DiskBuffer.
            </summary>
            <param name="dataBlockSize">Data Block of 'DataBlockSize' will be created and assigned as DiskBuffer</param>
        </member>
        <member name="M:Sop.Persistence.InternalPersistent.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Implement to Pack Persisted Data on a byte array for Serialization.
            </summary>
            <param name="parent">Collection this object is a member of</param>
            <param name="writer">Pack your data using this Writer</param>
        </member>
        <member name="M:Sop.Persistence.InternalPersistent.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            Given byte array read from stream, read the bytes needed to de-serialize this object by assigning
            to appropriate fields of this object the read data.
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
            <returns>0 if object completely Unpacked or the size of the Data waiting to be read on the stream.</returns>
        </member>
        <member name="M:Sop.Persistence.InternalPersistent.GetParent(Sop.Persistence.IInternalPersistent,System.Type,System.Boolean)">
            <summary>
            Traverse the Parent hierarchy and look for a Parent of a given Type.
            Example, one can look for the "File" container of a Collection or a Parent
            Collection of a Collection and so on and so forth..
            </summary>
            <param name="parent"> </param>
            <param name="findParentOfType"> </param>
            <param name="throwIfNotFound"> </param>
            <returns></returns>
        </member>
        <member name="P:Sop.Persistence.InternalPersistent.DiskBuffer">
            <summary>
            Default implementation is to retrieve the disk buffer from MRU,
            override if needed to read/save data from/to Disk if not in MRU
            </summary>
        </member>
        <member name="P:Sop.Persistence.InternalPersistent.HintSizeOnDisk">
            <summary>
            Implement to return the size on disk(in bytes) of this object
            </summary>
        </member>
        <member name="P:Sop.Persistence.InternalPersistent.IsDirty">
            <summary>
            IsDirty tells BTree whether this object needs to be rewritten to disk(dirty) or not
            </summary>
        </member>
        <member name="M:Sop.ItemOnDisk.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Sop.ItemOnDisk.#ctor(Sop.DataBlockSize)">
            <summary>
            Constructor expecting block size
            </summary>
            <param name="dataBlockSize"></param>
        </member>
        <member name="M:Sop.ItemOnDisk.#ctor(Sop.DataBlockSize,System.Object)">
            <summary>
            Constructor expecting block size and Data to be persisted to disk
            </summary>
            <param name="dataBlockSize"></param>
            <param name="data"></param>
        </member>
        <member name="M:Sop.ItemOnDisk.Clone">
            <summary>
            Copy contents of this Item On Disk and returns the new copy.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Sop.ItemOnDisk.Data">
            <summary>
            Data to save/read from file
            </summary>
        </member>
        <member name="M:Sop.ItemOnDisk.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Write the contents of this object to the stream bound to a Binary Writer.
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.ItemOnDisk.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            Unpack or read the contents of this object from a Binary Reader.
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="M:Sop.ItemOnDisk.ToString">
            <summary>
            Override ToString to write the address on disk of this Item.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sop.ItemOnDisk.IsDirty">
            <summary>
            true means this item on disk was modified since last load from disk,
            false otherwise.
            </summary>
        </member>
        <member name="P:Sop.ItemOnDisk.DataIsUserDefined">
            <summary>
            For internal use only.
            true means data is user defined, false otherwise.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.LinkedList.SharedBlockOnDiskList.PurifyMeta(Sop.OnDisk.Algorithm.LinkedList.LinkedListOnDisk.LinkedItemOnDisk,Sop.DataBlock)">
            <summary>
            Shared Block on Disk purifies data and only saves one
            copy of Meta data in it.
            </summary>
            <param name="biod"></param>
            <param name="db"></param>
        </member>
        <member name="T:Sop.OnDisk.DataBlock.DataBlockDriver">
            <summary>
            DataBlockDriver is a data block driver implementation for 
            writing/reading data blocks to/from a local file.
            </summary>
            <summary>
            DataBlockDriver is a data block driver implementation for 
            writing/reading data blocks to/from a local file.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.DataBlock.IDataBlockDriver">
            <summary>
            Data Block Driver interface extends IDataBlockFactory
            and adds data block management functions within a collection
            of a File.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.CreateBlock(Sop.DataBlockSize)">
            <summary>
            Instantiate a new Data block of a given size
            </summary>
            <param name="blockSize"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.GetId(Sop.DataBlock)">
            <summary>
            Returns the effective ID of the block. It can be the DataAddress
            or it can be a handle/reference to the block. DataBlockDriver
            implementation drives what GetID and SetID usage is
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.SetId(Sop.DataBlock,System.Int64)">
            <summary>
            Update the effective ID of the block with a given Value
            </summary>
            <param name="block"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.GetIsDirty(Sop.DataBlock)">
            <summary>
            true if block was modified, false otherwise
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.SetIsDirty(Sop.DataBlock,System.Boolean)">
            <summary>
            Mark block as modified or not
            </summary>
            <param name="targetBlock"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.Delete(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            Delete all of collection's data blocks and send them for recycling
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.MoveFirst(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            Move the current item pointer to the 1st item.
            The collection dictates which item is considered 1st according to
            its sort order, if it has sort order
            </summary>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.MoveLast(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            Move the current item pointer to the last item.
            </summary>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.MoveNext(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            Move the current item pointer to the next item.
            </summary>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.MoveTo(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,Sop.DataBlock)">
            <summary>
            Move the current item pointer to the item specified by DataAddress of a given Sop.DataBlock
            </summary>
            <param name="parent"></param>
            <param name="dataBlock"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.MoveTo(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,System.Int64)">
            <summary>
            Move the current item pointer to the item specified by DataAddress
            </summary>
            <param name="parent"></param>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.ReadBlockFromDisk(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,System.Int64,System.Boolean)">
            <summary>
            Read the block from disk
            </summary>
            <param name="parent"></param>
            <param name="address"></param>
            <param name="getForRemoval"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.ReadBlockFromDisk(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,System.Boolean)">
            <summary>
            Read the block from disk
            </summary>
            <param name="parent"></param>
            <param name="getForRemoval"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.Remove(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,Sop.DataBlock,System.Boolean)">
            <summary>
            Remove the block from disk and sends it for recycling
            </summary>
            <param name="parent"></param>
            <param name="block"></param>
            <param name="clearBlock"></param>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.SetDiskBlock(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,Sop.DataBlock,System.Boolean,System.Boolean)">
            <summary>
            Remove the block from disk and sends it for recycling
            </summary>
            <param name="parent"></param>
            <param name="block"></param>
            <param name="isCollectionBlock"> </param>
            <param name="addToMru"></param>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockDriver.WriteBlocksToDisk(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,System.Collections.Generic.IDictionary{System.Int64,Sop.DataBlock},System.Boolean)">
            <summary>
            Bulk write a given set of Blocks
            </summary>
            <param name="parent"></param>
            <param name="blocks"></param>
            <param name="clear"> </param>
            <returns></returns>
        </member>
        <member name="P:Sop.OnDisk.DataBlock.IDataBlockDriver.BlockRecycler">
            <summary>
            Block Recycler.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.DataBlock.IDataBlockDriver.HeaderData">
            <summary>
            get/set the HeaderData
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.CreateBlock(Sop.DataBlockSize)">
            <summary>
            Create a block of Data
            </summary>
            <param name="blockSize"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.MoveNext(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            MoveNext makes the next entry the current one
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.MoveFirst(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            MoveFirst makes the first entry in the Collection the current one
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.MoveLast(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            MoveLast makes the last entry in the Collection the current one
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.MoveTo(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,System.Int64)">
            <summary>
            Move parent Collection's file pointer to 'Address'.
            </summary>
            <param name="parent"></param>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.AllocateNextBlock(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,Sop.DataBlock,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Allocate next available block on disk.
            Returns true if all blocks had been allocated, false otherwise.
            </summary>
            <param name="parent"></param>
            <param name="block"></param>
            <param name="isHead"></param>
            <param name="isCollectionBlock"></param>
            <param name="addToMru"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.AddBlockToDisk(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,Sop.DataBlock,System.Boolean,System.Boolean,System.Boolean)">
            Header:
            OccupiedBlock Head
            OccupiedBlock Tail
            DeletedBlock Head
            DeletedBlock Tail
            
            Layout in Disk:
            Byte 0: Available or Occupied flag
            Byte 1 to 8: Next Item Address (64 bit long int)
            Byte 9 to 10: Size Occupied
            Byte 11 to 11 + Size Occupied: USER DATA
            Disk Layout:
            Block 1 -> Block 2 -> Block 3 -> Block n
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.SetDiskBlock(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,Sop.DataBlock,System.Boolean,System.Boolean)">
            <summary>
            Assign block(s) of space on disk to the Data Block(s).
            The assigned disk blocks' file offsets will be set as the blocks' DataAddresses.
            </summary>
            <param name="parent"></param>
            <param name="block">Data Block which will be assigned a block of space on disk</param>
            <param name="isCollectionBlock"> </param>
            <param name="addToMru">true will put the block into MRU, else not</param>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.WriteBlocksToDisk(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,System.Collections.Generic.IDictionary{System.Int64,Sop.DataBlock},System.Boolean)">
            <summary>
            Write a group of Blocks into Disk. NOTE: it will be more optimal if Blocks
            are sorted by its Data Address so this function can write contiguous blocks
            in one async write.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.ReadBlockFromDiskOrInitializeIfEmpty(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,System.Int64,System.Boolean,Sop.DataBlock)">
            <summary>
            Read Block from Disk
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.Remove(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,Sop.DataBlock,System.Boolean)">
            <summary>
            Remove Block from the Collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DataBlockDriver.Delete(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk)">
            <summary>
            Delete the Collection for recycling
            </summary>
        </member>
        <member name="P:Sop.OnDisk.DataBlock.DataBlockDriver.BlockRecycler">
            <summary>
            Block Recycler.
            </summary>
        </member>
        <member name="T:Sop.Mru.IMruManager">
            <summary>
            MRU cache Manager interface
            </summary>
        </member>
        <member name="M:Sop.Mru.IMruManager.Add(System.Object,System.Object)">
            <summary>
            Add a Key/Value pair to the MRU cache
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sop.Mru.IMruManager.Clear">
            <summary>
            Clear objects from MRU cache
            </summary>
        </member>
        <member name="M:Sop.Mru.IMruManager.Contains(System.Object)">
            <summary>
            Check whether object with Key is in cache
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.IMruManager.RemoveInTail(System.Boolean)">
            <summary>
            Remove item from the tail end with option to move the removed item onto remove list.
            </summary>
            <param name="moveToRemoveList"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.IMruManager.Recycle(Sop.Persistence.IInternalPersistent)">
            <summary>
            Recycle an object.
            </summary>
            <param name="recycledObject"></param>
        </member>
        <member name="M:Sop.Mru.IMruManager.GetRecycledObject">
            <summary>
            Return a recycled object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.IMruManager.Remove(System.Collections.ICollection,System.Boolean)">
            <summary>
            Remove Objects identified in keys.
            NOTE: during MaxCapacity, Objects pruning occurs by Remove getting
            invoked and removed Objects persisted to Disk/virtual target store.
            If RemoveFromCache is true, Objects are only removed from cache
            and not persisted to store
            </summary>
            <param name="keys"></param>
            <param name="removeFromCache"></param>
        </member>
        <member name="M:Sop.Mru.IMruManager.Remove(System.Object,System.Boolean)">
            <summary>
            Remove item with given key with an option to remove item from cache or not.
            </summary>
            <param name="key"></param>
            <param name="removeFromCache"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.IMruManager.Remove(System.Object)">
            <summary>
            Remove item with given key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.IMruManager.Flush">
            <summary>
            Save the Objects in cache to target store
            </summary>
        </member>
        <member name="M:Sop.Mru.IMruManager.SetDataStores(Sop.Mru.IMruClient,Sop.OnDisk.DataBlock.IDataBlockDriver)">
            <summary>
            Binds the MRU Client to the DataDriver. DataDriver is used
            for persistence of cached Objects to target store
            </summary>
            <param name="parent"></param>
            <param name="dataDriver"></param>
        </member>
        <member name="M:Sop.Mru.IMruManager.GetParent">
            <summary>
            Returns the Parent Collection.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sop.Mru.IMruManager.IsDirty">
            <summary>
            true means at least one item in MRU cache is dirty, otherwise all items aren't dirty
            </summary>
        </member>
        <member name="P:Sop.Mru.IMruManager.Count">
            <summary>
            Return count of Objects in cache
            </summary>
        </member>
        <member name="P:Sop.Mru.IMruManager.MaxCapacity">
            <summary>
            Maximum MRU Capacity. If count of Objects in cache reached this
            number, cache is pruned to the MinCapacity
            </summary>
        </member>
        <member name="P:Sop.Mru.IMruManager.MinCapacity">
            <summary>
            Minimum MRU Capacity.
            </summary>
        </member>
        <member name="P:Sop.Mru.IMruManager.Item(System.Object)">
            <summary>
            get/set Object to/from cache
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.Mru.IMruManager.Keys">
            <summary>
            Returns Keys of Objects in cache
            </summary>
        </member>
        <member name="P:Sop.Mru.IMruManager.Values">
            <summary>
            Returns Objects in cache
            </summary>
        </member>
        <member name="P:Sop.Mru.IMruManager.SaveState">
            <summary>
            Save State
            </summary>
        </member>
        <member name="P:Sop.Mru.IMruManager.GeneratePruneEvent">
            <summary>
            true will generate Prune events, else will not
            </summary>
        </member>
        <member name="T:Sop.Transaction.Transaction">
            <summary>
            Transaction contains the Begin, Commit and Rollback
            transaction methods' implementation.
            </summary>
            <summary>
            Transaction management class.
            Our transaction model:
            1) Two phase commit: 
            	- 1st phase, save all transaction changed records in the 
            collection on disk's transaction segment. Save the transaction log
            	- 2nd phase, update the changed records' current pointers to reference
            the updated records in transaction segment.
            2) Mark the transaction as completed. ie - delete the transaction table records,
            </summary>
            <summary>
            Transaction management class.
            Our transaction model:
            1) Two phase commit: 
            	- 1st phase, save all transaction changed records in the 
            collection on disk's transaction segment. Save the transaction log
            	- 2nd phase, update the changed records' current pointers to reference
            the updated records in transaction segment.
            2) Mark the transaction as completed. ie - delete the transaction table records,
            </summary>
        </member>
        <member name="M:Sop.Transaction.Transaction.ReadBlockFromBackup(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Read Block from log backup file
            </summary>
            <param name="collection"></param>
            <param name="dataAddress"></param>
            <param name="getForRemoval"></param>
            <param name="readMetaInfoOnly"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.Transaction.BackupData(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{Sop.Transaction.Transaction.RecordKey,Sop.OnDisk.Geometry.Region}})">
            <summary>
            Backup Data of a certain disk region onto the transaction log file
            </summary>
        </member>
        <member name="M:Sop.Transaction.Transaction.BackupData(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{Sop.Transaction.Transaction.RecordKey,Sop.OnDisk.Geometry.Region}},Sop.OnDisk.IO.ConcurrentIOPoolManager,Sop.OnDisk.IO.ConcurrentIOPoolManager)">
            <summary>
            Backup Data of a certain disk region onto the transaction log file
            </summary>
        </member>
        <member name="M:Sop.Transaction.Transaction.RegisterFileGrowth(Sop.OnDisk.Algorithm.Collection.CollectionOnDisk,System.Int64,System.Int64)">
            <summary>
            Register file growth
            </summary>
            <param name="collection"></param>
            <param name="segmentAddress"></param>
            <param name="segmentSize"></param>
        </member>
        <member name="M:Sop.Transaction.Transaction.RegisterAdd(Sop.Collections.Generic.ISortedDictionary{Sop.Transaction.Transaction.RecordKey,System.Int64},Sop.Collections.Generic.ISortedDictionary{Sop.Transaction.Transaction.RecordKey,System.Int64},Sop.Collections.Generic.ISortedDictionary{Sop.Transaction.Transaction.RecordKey,System.Int64},Sop.Transaction.Transaction.RecordKey,System.Int32,System.Boolean)">
            <summary>
            Check whether a block is a newly added block or is in new segment or recycle store.
            </summary>
            <param name="addStore"></param>
            <param name="fileGrowthStore"></param>
            <param name="recycledCollectionStore"></param>
            <param name="key"></param>
            <param name="blockSize"></param>
            <param name="checkIfInGrowthSegments"></param>
            <returns>true if block is either new, in new segment or in recycle store, false otherwise</returns>
        </member>
        <member name="M:Sop.Transaction.Transaction.RegisterAdd(Sop.OnDisk.Algorithm.Collection.CollectionOnDisk,System.Int64,System.Int32)">
            <summary>
            RegisterAdd will be called whenever a "new" block is allocated.
            Don't save block at this point as changes not saved yet.
            </summary>
            <param name="collection"></param>
            <param name="blockAddress"></param>
            <param name="blockSize"></param>
        </member>
        <member name="M:Sop.Transaction.Transaction.RegisterSave(Sop.OnDisk.Algorithm.Collection.CollectionOnDisk,System.Int64,System.Int32,Sop.OnDisk.IO.ConcurrentIOPoolManager,Sop.OnDisk.IO.ConcurrentIOPoolManager)">
            <summary>
            RegisterSave will be called when a block cache faulted from memory
            onto Disk. Resolution of Added blocks will be done here and only
            those "modified" blocks will be saved. Newly added block(s) will 
            not be saved.
            </summary>
            <param name="collection">Collection that is saving the block</param>
            <param name="blockAddress"></param>
            <param name="segmentSize"></param>
            <param name="readPool"> </param>
            <param name="writePool"> </param>
        </member>
        <member name="F:Sop.Transaction.Transaction.DiskBasedMetaLogging">
            <summary>
            true will use disk based transaction meta logging, otherwise in-memory.
            Default is in-memory AND disk based has yet to prove its need... probably
            in super large transaction where changes are in the span of Terabytes of
            non-contiguous blocks, which we haven't seen/imagined to be used yet AS
            SOP merges contiguous blocks as possible to minimize entries.
            </summary>
        </member>
        <member name="M:Sop.Transaction.Transaction.Dispose">
            <summary>
            Dispose all resources and close all transaction opened collections/files.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sop.Transaction.Transaction.BeginWithNewRoot(Sop.ObjectServerWithTransaction)" -->
        <member name="M:Sop.Transaction.Transaction.Commit">
            <summary>
            Commit changes to Containers/members of this Transaction
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.Transaction.Rollback">
            <summary>
            Rollback changes to Containers/members of this Transaction
            </summary>
        </member>
        <member name="M:Sop.Transaction.Transaction.RollbackConflicts">
            <summary>
            Roll back other transaction(s) that modified one or more blocks
            modified also by this transaction
            </summary>
        </member>
        <member name="M:Sop.Transaction.Transaction.InternalCommit(Sop.Transaction.CommitPhase)">
             <summary>
             Commit a transaction
             </summary>
             <param name="phase">
             FirstPhase will make changes permanent but keep transaction log so rollback 
             is still possible.
             
             SecondPhase will:
             1. call FirstPhase commit if this transaction is in UnCommitted phase
             2. clear the transaction log to complete Commit
             NOTE: Rollback is no longer allowed after completion of SecondPhase
             </param>
            <returns>true if successful otherwise false</returns>
        </member>
        <member name="M:Sop.Transaction.Transaction.BeginOpenServer(System.String,Sop.Preferences)">
            <summary>
            Begin transaction and open the ObjectServer in the specified path/filename
            </summary>
            <param name="serverFilename"></param>
            <param name="serverProfile"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.Transaction.RollbackAll(System.String,Sop.Preferences,System.Boolean)">
            <summary>
            Rollback uncomitted transactions.
            NOTE: this should be invoked upon restart so uncommited transaction(s)
            when program quits in previous run can be rolled back.
            </summary>
            <param name="serverFilename"> </param>
            <param name="serverProfile"> </param>
            <param name="createOpenObjectServerIfNoRollbackLog"> </param>
        </member>
        <member name="F:Sop.Transaction.Transaction.Count">
            <summary>
            Count of ongoing transactions for the entire application
            </summary>
        </member>
        <member name="M:Sop.Transaction.Transaction.InternalRollback(System.Boolean)">
            <summary>
            Rollback a transaction
            </summary>
        </member>
        <member name="F:Sop.Transaction.Transaction._fileGrowthStore">
            <summary>
            Transaction File Growth Store keeps information about Segments
            that were created within the transaction. The information is used
            during rollback to recycle those segments.
            </summary>
        </member>
        <member name="P:Sop.Transaction.Transaction.IsGlobal">
            <summary>
            true means there is one and only one transaction and all changes
            are seen globally. The only Transaction is either committed or rolled back.
            </summary>
        </member>
        <member name="M:Sop.Transaction.Transaction.RecordKeyComparer2`1.Compare(`0,`0)">
            <summary>
            Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <returns>
            Value 
                                Condition 
                                Less than zero
                            <paramref name="x"/> is less than <paramref name="y"/>.
                                Zero
                            <paramref name="x"/> equals <paramref name="y"/>.
                                Greater than zero
                            <paramref name="x"/> is greater than <paramref name="y"/>.
            </returns>
            <param name="x">The first object to compare.
                            </param><param name="y">The second object to compare.
                            </param>
        </member>
        <member name="F:Sop.Transaction.Transaction.BackupDataLogValue.TransactionId">
            <summary>
            ID of "winning" transaction that caused data to get backed up
            </summary>
        </member>
        <member name="T:Sop.Transaction.Transaction.RecordKey">
            <summary>
            Transaction "Action" Record Key
            </summary>
        </member>
        <member name="T:Sop.OnDisk.DataReference">
            <summary>
            Data Reference class
            </summary>
        </member>
        <member name="T:Sop.OnDisk.CollectionReference">
            <summary>
            Collection Reference class.
            Used for persisting collection reference information part of 
            transaction support.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.CollectionReference.CollectionName">
            <summary>
            Name of Collection on Disk that contains the Data
            </summary>
        </member>
        <member name="F:Sop.OnDisk.CollectionReference.Filename">
            <summary>
            Filename where the data is stored
            </summary>
        </member>
        <member name="F:Sop.OnDisk.CollectionReference.ServerSystemFilename">
            <summary>
            Object Server System filename
            </summary>
        </member>
        <member name="F:Sop.OnDisk.DataReference.Address">
            <summary>
            Offset in file where the first byte of data is stored
            </summary>
        </member>
        <member name="T:Sop.Transaction.Transaction.Record">
            <summary>
            Transaction "Action" Record contains information about a management 
            action done to an ObjectTable.
            </summary>
        </member>
        <member name="F:Sop.Transaction.Transaction.Record.Key">
            <summary>
            Record Key
            </summary>
        </member>
        <member name="F:Sop.Transaction.Transaction.Record.Data">
            <summary>
            RecordData contains the block's data before it got updated.
            During rollback, this data is applied to the block to restore or undo changes.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.ConcurrentWrappers.ConcurrentCollectionOnDisk`1">
            <summary>
            Concurrent Collection On Disk.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk">
            <summary>
            2nd part of the BTreeNodeOnDisk class
            </summary>
            <summary>
            B-Tree Node On Disk
            </summary>
        </member>
        <member name="T:Sop.Recycling.IRecyclable">
            <summary>
            Recyclable interface
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.IBTreeNodeOnDisk">
            <summary>
            BTree Node On Disk interface
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.#ctor(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,System.Int64)">
            <summary>
            Constructor expecting ParentTree and ParentNode params.
            This form is invoked from another instance of this class when node 
            splitting occurs. Normally, node split occurs to accomodate new items that
            could not be loaded to the node since the node is already full. 
            Calls <see cref="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Initialize(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,System.Int64)"/> for member initialization.
            </summary>
            <param name="bTree">Parent B-Tree instance</param>
            <param name="parentNodeAddress">Parent Node instance</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Pack serializes this node to the Stream.
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            Unpack Deserializes Node from Stream
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Initialize(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,System.Int64)">
            <summary>
            Do class variable/object initialization. Usually invoked from this class' constructor.
            </summary>
            <param name="bTree">Parent BTree</param>
            <param name="parentNodeAddress">Parent Node</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.IsFull(System.Int16)">
            <summary>
            Returns true if slots are all occupied, else false
            </summary>
            <param name="slotLength">Number of slots per node</param>
            <returns>true if full, else false</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.CopyArrayElements``1(``0[],System.Int32,``0[],System.Int32,System.Int32)">
            <summary>
            "CopyArrayElements" copies elements of an array (Source) to destination array (Destination).
            </summary>
            <param name="source">Array to copy elements from</param>
            <param name="srcIndex">Index of the 1st element to copy</param>
            <param name="destination">Array to copy elements to</param>
            <param name="destIndex">Index of the 1st element to copy to</param>
            <param name="count">Number of elements to copy</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.MoveArrayElements``1(``0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            "Shallow" move elements of an array. 
            "MoveArrayElements" moves a group (Count) of elements of an array from
            source index to destination index.
            </summary>
            <param name="array">Array whose elements will be moved</param>
            <param name="srcIndex">Source index of the 1st element to move</param>
            <param name="destIndex">Target index of the 1st element to move to</param>
            <param name="count">Number of elements to move</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.ResetArray``1(``0[],``0,System.Int32)">
            <summary>
            Reset all elements of the array to Value
            </summary>
            <param name="array">Array to reset all elements of</param>
            <param name="value">Value to assign to each element of the array</param>
            <param name="itemCount"> </param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.ShiftSlots``1(``0[],System.Int32,System.Int32)">
            <summary>
            Skud over one slot all items to the right.
            The 1st element moved will then be vacated ready for an occupant.
            </summary>
            <param name="slots">"Slots" to skud over its contents</param>
            <param name="position">1st element index to skud over</param>
            <param name="noOfOccupiedSlots">Number of occupied slots</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Add(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk,Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk)">
            <summary>
            Recursive Add function.
            NOTE: Actual addition of node item happens at the
            outermost (ie - nodes having no children) level.
            </summary>
            <param name="bTree">Parent BTree</param>
            <param name="item">Item to add to the tree</param>
            <param name="parent"> </param>
            <throws>Exception if No Comparer or Mem Alloc err is encountered.</throws>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Clear">
            <summary>
            Clear reinitialize this Node
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Remove(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Remove the current item from the tree
            </summary>
            <param name="bTree">Parent BTree</param>
            <returns>Always returns true</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.PullFromLeft(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Recursively pull item from left side. Modified to process unbalanced branch - 10/31/97.
            Pull an item from the left siblings. Used when this node run out of loaded items and 
            instead of destroying itself, will pull an item from the left siblings to maintain the balanceness of this tree branch
            </summary>
            <param name="bTree">Parent BTree</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.PullFromRight(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Recursively pull item from right side. Modified to process unbalanced branch - 10/31/97
            Same as above except that the pull is from the right siblings.
            </summary>
            <param name="bTree">Paren BTree</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.FixTheVacatedSlot(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Overwrite the current item with the item from the next or previous slot.
            Attempts to free the TreeNode object by setting Parent, Children and Slots to null.
            </summary>
            <param name="bTree">Parent BTree</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.SearchForPullableItem(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,System.Int16@)">
            <summary>
            Search for a pullable item from sibling nodes of this node. Modified for unbalanced branch's correct detection of pullable item. -10/31/97
            Find a pullable item. Will return true if there is one.
            </summary>
            <param name="bTree"> </param>
            <param name="index">Will be updated of the pullable item's index in the slot</param>
            <returns>true if there is pullable item, else false</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.GetIndexOfNode(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Returns index of this node relative to parent. 
            Note: you must call this after you check that there is a parent node.
            </summary>
            <param name="bTree"> </param>
            <returns>Index of this node per its parent</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Search(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,System.Object,System.Boolean)">
            <summary>
            Search BTreeAlgorithm for the item pointed to by Item. 
            NOTE: this should be invoked from root node.
            </summary>
            <param name="bTree">BTree this Node is a branch of</param>
            <param name="item">Item to search in tree</param>
            <param name="goToFirstInstance">true tells BTree to go to First Instance of Key, else any key instance matching will match</param>
            <returns>true if item found, else false</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.MoveFirst(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Make the first item the current item. This member should be called from Root.
            </summary>
            <param name="bTree">BTree instance this Node is a part of</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.MoveNext(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Make the next item in the tree the current item.
            </summary>
            <param name="bTree">Parent BTree</param>
            <returns>true if successful, else false</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Promote(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,System.Int16)">
            <summary>
            This gets called when the node's slots are overflowed and break up
            is needed. This does the necessary recursive promotion of the 
            newly born nodes as affected by the break up.<br/>
            Uses caller Btree object's Temporary Slots and Children nodes
            which are accessible via GetTempSlot() and _GetTempParentChildren()
            as temp storage of Parent and newly born siblings as nodes are 
            re-arranged.
            </summary>
            <param name="bTree">parent BTree</param>
            <param name="position">Position of the broken apart node in its parent node's slots</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.DistributeToLeft(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk)">
            <summary>
            Distribute to left siblings the item if the current slots are all filled up.
            Used when balancing the nodes' load of the current sub-tree.
            </summary>
            <param name="item">Item to distribute to left sibling node</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.DistributeToRight(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk)">
            <summary>
            Distribute to right siblings the item if the current slots are all filled up.
            Used when balancing the nodes' load of the current sub-tree.
            </summary>
            <param name="bTree"> </param>
            <param name="item">Item to distribute to right sibling</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.GetLeftSibling(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Returns left sibling or null if finished traversing left nodes.
            </summary>
            <returns>Left sibling BTreeNodeOnDisk reference</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.GetRightSibling(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Returns right sibling or null if finished traversing right nodes.
            </summary>
            <returns>Right sibling BTreeNodeOnDisk reference</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.IsThereVacantSlotInLeft(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,System.Boolean@)">
            <summary>
            Returns true if a slot is available in left side siblings of this node modified to suit possible unbalanced branch.
            </summary>
            <param name="bTree">Parent BTree</param>
            <param name="isUnBalanced">Will be updated to true if this branch is detected to be "unbalanced", else false</param>
            <returns>true if there is a vacant slot, else false</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.IsThereVacantSlotInRight(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,System.Boolean@)">
            <summary>
            Returns true if a slot is available in right side siblings of this node modified to suit possible unbalanced branch.
            </summary>
            <param name="bTree">Parent BTree</param>
            <param name="isUnBalanced">Will be updated to true if this branch is detected to be "unbalanced", else false</param>
            <returns>true if there is a vacant slot, else false</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.GetChildren(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm)">
            <summary>
            Reads the Children Nodes from Disk and return them in Array
            </summary>
            <param name="bTree"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.GetChild(Sop.OnDisk.Algorithm.BTree.BTreeAlgorithm,System.Int16)">
            <summary>
            Read the Child from Cache of from Disk
            </summary>
            <param name="bTree"></param>
            <param name="slotIndex"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.IsDirty">
            <summary>
            IsDirty tells BTree whether this object needs to be rewritten to disk(dirty) or not
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.DiskBuffer">
            <summary>
            Node disk buffer.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.HintSizeOnDisk">
            <summary>
            Return the size on disk(in bytes) of this object
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.Count">
            <summary>
            Count of items in this B-Tree
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.BTreeNodeOnDisk.ItemAddress">
            <summary>
            A BTreeAlgorithm's item address is composed of the node's address + the item's index in the Slots.
            </summary>
        </member>
        <member name="F:Sop.Mru.Generic.InternalMruManager`2.GeneratePruneEvent">
            <summary>
            Generate prune event
            </summary>
        </member>
        <member name="T:Sop.Mru.Generic.IMruManager`2">
            <summary>
            MRU cache Manager interface
            </summary>
        </member>
        <member name="M:Sop.Mru.Generic.IMruManager`2.Add(`0,`1)">
            <summary>
            Add a Key/Value pair to the MRU cache
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sop.Mru.Generic.IMruManager`2.Clear">
            <summary>
            Clear objects from MRU cache
            </summary>
        </member>
        <member name="M:Sop.Mru.Generic.IMruManager`2.Contains(`0)">
            <summary>
            Check whether object with Key is in cache
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.Generic.IMruManager`2.Remove(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove Objects identified in keys.
            NOTE: during MaxCapacity, Objects pruning occurs by Remove getting
            invoked and removed Objects persisted to Disk/virtual target store.
            If RemoveFromCache is true, Objects are only removed from cache
            and not persisted to store
            </summary>
            <param name="keys"></param>
        </member>
        <member name="M:Sop.Mru.Generic.IMruManager`2.Remove(`0)">
            <summary>
            Remove item from MRU.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.Generic.IMruManager`2.Flush">
            <summary>
            Save the Objects in cache to target store
            </summary>
        </member>
        <member name="M:Sop.Mru.Generic.IMruManager`2.SetDataStores(Sop.Mru.IMruClient)">
            <summary>
            Binds the MRU Client to the DataDriver. DataDriver is used
            for persistence of cached Objects to target store
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:Sop.Mru.Generic.IMruManager`2.PeekInTail">
            <summary>
            Peek in tail.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.Generic.IMruManager`2.RemoveInTail">
            <summary>
            Get and remove item from tail. This is useful during MaxCapacity when code is reducing MRU load.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sop.Mru.Generic.IMruManager`2.Count">
            <summary>
            Return count of Objects in cache
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.IMruManager`2.IsFull">
            <summary>
            true if MRU is in MaxCapacity, false otherwise.
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.IMruManager`2.MaxCapacity">
            <summary>
            Maximum MRU Capacity. If count of Objects in cache reached this
            number, cache is pruned to the MinCapacity
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.IMruManager`2.MinCapacity">
            <summary>
            Minimum MRU Capacity.
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.IMruManager`2.Item(`0)">
            <summary>
            get/set Object to/from cache
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.Mru.Generic.IMruManager`2.Keys">
            <summary>
            Returns Keys of Objects in cache
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.IMruManager`2.MruItems">
            <summary>
            Returns Objects in cache
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.IMruManager`2.SaveState">
            <summary>
            Save State
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.IMruManager`2.GeneratePruneEvent">
            <summary>
            true will generate Prune events, else will not
            </summary>
        </member>
        <member name="T:Sop.StoreFactory">
            <summary>
            Store Factory is the hub for creation or retrieval
            of an object Store (sorted dictionary on disk).
            
            Currently supported Serialization techniques are:
            * Basic (simple) type Serialization.
                e.g. - int, float, char, string, double, long, etc... 
                are serialized using respective method of the Binary Writer.
            * Basic with POCO Xml Serialization. Basic types as listed above are serialized 
                using Binary Writer and POCO using Xml Serializer.
            * Basic with POCO SOP.IPersistent implements. Basic types are
                serialized using Binary Writer and POCO using code implementation of
                Pack/Unpack methods of the IPersistent interface.
            </summary>
        </member>
        <member name="T:Sop.IStoreFactory">
            <summary>
            Store Factory interface.
            
            Supported Serialization techniques are:
            * Basic (simple) type Serialization
            * Object Xml Serialization
            * Object SOP.IPersistent implements
            </summary>
        </member>
        <member name="M:Sop.IStoreFactory.Get``2(System.Object,System.String,System.Collections.Generic.IComparer{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create/Get a general purpose Data Store. Key and/or Value types can be any of the following data types:
                - simple type, e.g. - int, short, string, char, float, etc...
                - Xml Serializable object.
            NOTE: simple type data are stored in non-Xml format for space optimization reasons.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="createIfNotExist"></param>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <param name="mruManaged"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.IStoreFactory.Remove(System.Object,System.String)">
            <summary>
            Remove a Data Store from its container.
            </summary>
            <param name="container">data store container</param>
            <param name="name">name of the Data Store to remove</param>
        </member>
        <member name="M:Sop.IStoreFactory.GetPersistent``2(System.Object,System.String,System.Collections.Generic.IComparer{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create/Get Data Store for both IPersistent Typed Key and Value
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="createIfNotExist"></param>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <param name="mruManaged"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.IStoreFactory.GetPersistentKey``2(System.Object,System.String,System.Collections.Generic.IComparer{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create/Get Data Store for IPersistent typed Key and "Simple typed" Value.
            NOTE: Simple type means one of the integer, numeric(decimal, float...), char data types, byte array
            or a string
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="createIfNotExist"></param>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <param name="mruManaged"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.IStoreFactory.GetPersistentValue``2(System.Object,System.String,System.Collections.Generic.IComparer{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create/Get Data Store for IPersistent typed Value and "Simple typed" Key.
            NOTE: Simple type means one of the integer, numeric(decimal, float,...), char data types, byte array
            or a string
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="createIfNotExist"></param>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <param name="mruManaged"> </param>
            <returns></returns>
        </member>
        <member name="P:Sop.IStoreFactory.AutoDisposeItem">
            <summary>
            Auto Dispose Store when it gets removed from Cache.
            </summary>
        </member>
        <member name="F:Sop.StoreFactory.DefaultMaxOpenStoreInMemoryCount">
            <summary>
            Default maximum number of Stores to be kept opened in memory by StoreFactory.
            </summary>
        </member>
        <member name="M:Sop.StoreFactory.Get``2(System.Object,System.String,System.Collections.Generic.IComparer{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create/Get a general purpose Data Store. Key and/or Value types can be any of the following:
                - simple type, e.g. - int, short, string, char, float, etc...
                - Xml serializable object.
            NOTE: simple type data are stored in non-Xml format for space optimization reasons.
            
            NOTE 2: this is a multi-thread safe method.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="createIfNotExist"></param>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <param name="mruManaged">true means the returned store's lifetime is managed by StoreFactory using MRU algorithm.
            i.e. - least recently used store(s) will be most likely auto-disposed when number of stores accessed by code reached MRU maximum threshold count.</param>
            <returns></returns>
        </member>
        <member name="M:Sop.StoreFactory.Remove(System.Object,System.String)">
            <summary>
            Remove a Data Store from its container.
            NOTE: this is thread-safe.
            </summary>
            <param name="container">data store container</param>
            <param name="name">name of the Data Store to remove</param>
        </member>
        <member name="M:Sop.StoreFactory.GetPersistent``2(System.Object,System.String,System.Collections.Generic.IComparer{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create/Get Data Store for both IPersistent Typed Key and Value
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="createIfNotExist"></param>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <param name="mruManaged"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.StoreFactory.GetPersistentKey``2(System.Object,System.String,System.Collections.Generic.IComparer{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create/Get Data Store for IPersistent typed Key and "Simple typed" Value.
            NOTE: Simple type means one of the integer, numeric(decimals,...), char data types, byte array
            or a string
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="createIfNotExist"></param>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <param name="mruManaged"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.StoreFactory.GetPersistentValue``2(System.Object,System.String,System.Collections.Generic.IComparer{``0},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Create/Get Data Store for IPersistent typed Value and "Simple typed" Key.
            NOTE: Simple type means one of the integer, numeric(decimals,...), char data types, byte array
            or a string
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="createIfNotExist"></param>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.StoreFactory.GetContainer(System.Object)">
            <summary>
            Returns a valid container of correct type
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="F:Sop.StoreFactory.OpenedStores">
            <summary>
            Opened Stores MRU cache.
            </summary>
        </member>
        <member name="P:Sop.StoreFactory.AutoDisposeItem">
            <summary>
            Auto Dispose Store when it gets removed from B-Tree Cache.
            Defaults to false as StoreFactory Getter by default provides
            MRU caching of stores and it manages auto-dispose of stores least
            used.
            </summary>
        </member>
        <member name="P:Sop.StoreFactory.MaxStoreInstancePoolCount">
            <summary>
            Maximum number of Opened Data Stores in-memory.
            NOTE: When total number of opened and in-memory Stores 
            reach this amount, StoreFactory will start to auto-dispose
            least used opened Stores in-memory in order to maintain 
            memory/resource consumption within reasonable levels.
            </summary>
        </member>
        <member name="T:Sop.Transaction.TransactionRolledbackException">
            <summary>
            Transaction Rolledback Exception
            </summary>
        </member>
        <member name="T:Sop.ISortedDictionaryOnDisk">
            <summary>
            Sorted Dictionary On Disk contains Sorted Dictionary like members plus
            additional disk I/O specific methods.
            </summary>
        </member>
        <member name="T:Sop.IBTreeBase">
            <summary>
            B-Tree Base interface. Both In-Memory and On-Disk
            B-Tree versions implement IBTreeBase interface.
            </summary>
        </member>
        <member name="M:Sop.IBTreeBase.EndOfTree">
            <summary>
            Returns true if current record pointer is beyond last item in tree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.IBTreeBase.Search(System.Object)">
            <summary>
            Search BTreeAlgorithm for the entry having its key equal to 'Key'
            </summary>
            <param name="key">Key of record to search for</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="M:Sop.IBTreeBase.Search(System.Object,System.Boolean)">
            <summary>
            Search btree for the entry having its key equal to 'Key'
            </summary>
            <param name="key">Key of record to search for</param>
            <param name="goToFirstInstance">if true and Key is duplicated, will make first instance of duplicated keys the current record so one can easily get/traverse all records having the same keys using 'MoveNext' function</param>
            <returns>true if successful, false otherwise</returns>
        </member>
        <member name="P:Sop.IBTreeBase.SortOrder">
            <summary>
            Returns current sort order. Setting to a different sort order will 
            reset BTree. First item according to sort order will be current item.
            </summary>
        </member>
        <member name="P:Sop.IBTreeBase.CurrentKey">
            <summary>
            Returns current item's key
            </summary>
        </member>
        <member name="P:Sop.IBTreeBase.CurrentValue">
            <summary>
            Returns/sets current item's value
            </summary>
        </member>
        <member name="P:Sop.IBTreeBase.CurrentEntry">
            <summary>
            Returns the number of items in the btree
            </summary>
            <summary>
            Returns the current item (value and key pair) contained in 'DictionaryEntry' object.
            </summary>
        </member>
        <member name="M:Sop.ISortedDictionaryOnDisk.GetValue(System.Object,Sop.Persistence.IPersistent)">
            <summary>
            Get the Value given a Key
            </summary>
            <param name="key"></param>
            <param name="target">Valid Target which will contain the data read from Disk. 
            NOTE: this should be a valid instance, argument null exception will be thrown if null is passed in</param>
            <returns>Target</returns>
        </member>
        <member name="M:Sop.ISortedDictionaryOnDisk.GetCurrentValue(Sop.Persistence.IPersistent)">
            <summary>
            Get the Current Item's Value.
            NOTE: call one of the Move functions or the Search/Contains 
            function to position the Item pointer to the one you are interested
            about(Key) then call GetCurrentValue to get the Item Value
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.ISortedDictionaryOnDisk.Query(Sop.QueryExpression[],Sop.QueryResult[]@)">
            <summary>
            Query the B-Tree for each Keys submitted, retrieve their values
            and store them in the array out parameter Values
            </summary>
            <param name="keys"></param>
            <param name="values"></param>
            <returns>true if at least a key gets a match, otherwise false</returns>
        </member>
        <member name="P:Sop.ISortedDictionaryOnDisk.Comparer">
            <summary>
            Comparer for use in comparing Item Keys of the Dictionary on disk
            </summary>
        </member>
        <member name="P:Sop.ISortedDictionaryOnDisk.Container">
            <summary>
            Container dictionary
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Sop.ISortedDictionaryOnDisk.IsDataInKeySegment" -->
        <member name="P:Sop.ISortedDictionaryOnDisk.AutoDisposeItem">
            <summary>
            Auto Dispose Item of this Store when it gets removed from Cache or when it gets deleted.
            </summary>
        </member>
        <member name="P:Sop.ISortedDictionaryOnDisk.AutoDispose">
            <summary>
            Auto Dispose this Store when it gets removed from the container's cache.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.ISortedDictionaryOnDisk.IndexBlockSize">
            <summary>
            Index Block Size
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.ISortedDictionaryOnDisk.Transaction">
            <summary>
            Transaction Logger
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Geometry.Region">
            <summary>
            Use Region to allow mathematical operations on 
            a disk segment. Given a certain region on disk, one
            can subtract disk area(s) from it.
            The remaining areas(disk address and size) are 
            returned via an enumerator.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Geometry.Region.#ctor(System.Int64,System.Int32)">
            <summary>
            Expects a file Offset (a.k.a. data Address) and
            region size. The region starts from Address onto
            Address + Size.
            </summary>
            <param name="address"></param>
            <param name="size"></param>
        </member>
        <member name="M:Sop.OnDisk.Geometry.Region.GetEnumerator">
            <summary>
            Returns an enumerator for iterating through each disk area on this Region
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Geometry.Region.Subtract(System.Int64,System.Int32)">
            <summary>
            Subtract a disk area from this region
            </summary>
            <param name="address"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.OnDisk.Geometry.Region.Count">
            <summary>
            Count of Segments in this Disk Region
            </summary>
        </member>
        <member name="T:Sop.SopException">
            <summary>
            SOP exception.
            </summary>
        </member>
        <member name="T:Sop.Collections.BTree.Synchronizer">
            <summary>
            Synchronizer wraps thread synchronization on Collection code.
            Instances of this class can serve as SyncRoot for any collection type classes
            </summary>
        </member>
        <member name="T:Sop.Collections.BTree.ISynchronizer">
            <summary>
            Thread Synchronization interface.
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.Synchronizer.Lock(Sop.OperationType)">
            <summary>
            Lock Synchronizer.
            </summary>
            <param name="requestedOperation">Lock resource for Read, Write or Search</param>
        </member>
        <member name="M:Sop.Collections.BTree.Synchronizer.Unlock(Sop.OperationType)">
            <summary>
            Unlock Synchronizer.
            </summary>
        </member>
        <member name="P:Sop.Collections.BTree.Synchronizer.IsLocked">
            <summary>
            true if there is at least a single lock onto this object, false otherwise.
            </summary>
        </member>
        <member name="T:Sop.Collections.BTree.LegacySynchronizer">
            <summary>
            Synchronizer wraps thread synchronization on Collection code.
            Instances of this class can serve as SyncRoot for any collection type classes
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.LegacySynchronizer.Lock(Sop.OperationType)">
            <summary>
            Lock Synchronizer.
            </summary>
            <param name="requestedOperation">Lock resource for Read, Write or Search</param>
        </member>
        <member name="M:Sop.Collections.BTree.LegacySynchronizer.Unlock(Sop.OperationType)">
            <summary>
            Unlock Synchronizer.
            </summary>
        </member>
        <member name="F:Sop.Collections.BTree.LegacySynchronizer._readCount">
            <summary>
            count of threads in read operation.
            </summary>
        </member>
        <member name="P:Sop.Collections.BTree.LegacySynchronizer.IsLocked">
            <summary>
            true if there is at least a single lock onto this object, false otherwise.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.ObjectServer">
             <summary>
             Object Very Large Database Server (ObjectServer).
             It takes full advantage of the Grid resources.
            
             Grid Tree:
             When insertion made, check if disk/mem full, distribute half of the tree to another Computer. ie, get the sub-tree(s)
             of root and move them to the other PC.
             When deletion made, check whether there are PCs' whose loads can be combined to 1 PC to 
             optimize performance.
             
             -ObjectServer can have multiple instances on the same PC, so, no internal singleton please..
             </summary>
        </member>
        <member name="T:Sop.OnDisk.IObjectServer">
            <summary>
            Object Server interface specifically for On Disk use-case.
            </summary>
        </member>
        <member name="T:Sop.IObjectServer">
            <summary>
            Object Server interface.
            </summary>
        </member>
        <member name="T:Sop.Client.IObjectServer">
            <summary>
            Object Server interface.
            </summary>
        </member>
        <member name="M:Sop.Client.IObjectServer.GetFile(System.String)">
            <summary>
            Return the File with a given name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.Client.IObjectServer.Encoding">
            <summary>
            Encoding, defaults to UTF-8
            </summary>
        </member>
        <member name="P:Sop.Client.IObjectServer.Filename">
            <summary>
            Returns the Server's System Filename.
            </summary>
        </member>
        <member name="P:Sop.Client.IObjectServer.FileSet">
            <summary>
            Returns the Server's File Set.
            </summary>
        </member>
        <member name="P:Sop.Client.IObjectServer.ReadOnly">
            <summary>
            true if Server is in read-only mode.
            </summary>
        </member>
        <member name="P:Sop.Client.IObjectServer.Name">
            <summary>
            Returns the Server's Name.
            </summary>
        </member>
        <member name="P:Sop.Client.IObjectServer.Path">
            <summary>
            Returns the Server's physical data file path.
            </summary>
        </member>
        <member name="P:Sop.Client.IObjectServer.SystemFile">
            <summary>
            Returns the Server's System File.
            </summary>
        </member>
        <member name="M:Sop.IObjectServer.Close">
            <summary>
            Close the entire Server including each File(s) and each File's Object Store.
            </summary>
        </member>
        <member name="M:Sop.IObjectServer.GetFile(System.String)">
            <summary>
            Return the File with a given name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.IObjectServer.Open">
            <summary>
            Open the Server.
            </summary>
        </member>
        <member name="M:Sop.IObjectServer.Flush">
            <summary>
            Save changes to the Server.
            </summary>
        </member>
        <member name="M:Sop.IObjectServer.BeginTransaction">
            <summary>
            Begin a Transaction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.IObjectServer.Commit">
            <summary>
            Commint all changes to the current transaction.
            </summary>
        </member>
        <member name="M:Sop.IObjectServer.Rollback">
            <summary>
            Rollback all changes of the current transaction.
            </summary>
        </member>
        <member name="P:Sop.IObjectServer.Profile">
            <summary>
            Returns the Server profile.
            </summary>
        </member>
        <member name="P:Sop.IObjectServer.StoreTypes">
            <summary>
            Returns the Create Store Log table.
            </summary>
        </member>
        <member name="P:Sop.IObjectServer.FileSet">
            <summary>
            Returns the Server's File Set.
            </summary>
        </member>
        <member name="P:Sop.IObjectServer.IsDirty">
            <summary>
            true if Server was modified.
            </summary>
        </member>
        <member name="P:Sop.IObjectServer.IsNew">
            <summary>
            true if Server was just created.
            </summary>
        </member>
        <member name="P:Sop.IObjectServer.IsOpen">
            <summary>
            true if Server is Open.
            </summary>
        </member>
        <member name="P:Sop.IObjectServer.SystemFile">
            <summary>
            Returns the Server's System File.
            </summary>
        </member>
        <member name="P:Sop.IObjectServer.Transaction">
            <summary>
            Transaction object.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.ObjectServer.ObjectServerLiteral">
            <summary>
            Object Server literal text
            </summary>
        </member>
        <member name="F:Sop.OnDisk.ObjectServer.DataInfExtensionLiteral">
            <summary>
            Object Server Data file Inf extension literal.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.ObjectServer.DefaultFileExtension">
            <summary>
            Returns the default file extension of the Object Server
            </summary>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.#ctor(System.String,Sop.Transaction.TransactionRoot,Sop.Preferences,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="filename"></param>
            <param name="transLogger"> </param>
            <param name="profileScheme"> </param>
            <param name="readOnly"> </param>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.Initialize(System.String)">
            <summary>
            Initialize this Object Server. NOTE: this is created for SOP internal use only.
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.NormalizePath(System.String)">
            <summary>
            If Filename is not a complete path, returns Filename
            relative to this ObjectServer's Path.
            Otherwise return Filename unchanged.
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.NormalizePath(System.String,System.String)">
            <summary>
            If Filename is not a complete path, returns Filename
            relative to the passed in Server Path. Otherwise return Filename unchanged.
            </summary>
            <param name="serverPath"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.CreateDictionaryOnDisk(Sop.OnDisk.File.IFile)">
            <summary>
            Create Dictionary On Disk
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.CreateDictionaryOnDisk(Sop.OnDisk.File.IFile,System.Collections.IComparer)">
            <summary>
            Create Dictionary On Disk
            </summary>
            <param name="file"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.CreateDictionaryOnDisk(Sop.OnDisk.File.IFile,System.Collections.IComparer,System.String,System.Boolean)">
            <summary>
            Create Dictionary On Disk
            </summary>
            <param name="file"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.Dispose">
            <summary>
            Dispose this Object Server
            </summary>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.Flush">
            <summary>
            Save changes made to all Files including System File.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.Unload">
            <summary>
            Unload this Object Server
            </summary>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.Open">
            <summary>
            Open the Object Server
            </summary>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.Close">
            <summary>
            Close the Object Server
            </summary>
        </member>
        <member name="M:Sop.OnDisk.ObjectServer.GetFile(System.String)">
            <summary>
            Returns the File object with its Name equal to Name argument
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="F:Sop.OnDisk.ObjectServer.StoreTypesLiteral">
            <summary>
            Returns the Create Store Logs literal text.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.Profile">
            <summary>
            Object Server's Profile Scheme. Defaults to Embedded device
            profile scheme. Select Server or Enterprise scheme if wanting
            to utilize more of this server's memory and to allocate
            BIG Data Segments during Collection on disk's grow event.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.Path">
            <summary>
            Server root path.
            NOTE: set is for SOP used internally
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.IsDirty">
            <summary>
            IsDirty tells BTree whether this object needs to be rewritten to disk(dirty) or not
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.Encoding">
            <summary>
            Server encoding.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.IsOpen">
            <summary>
            true if Object Server is open, otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.IsNew">
            <summary>
            true means File is new, otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.WriteLogs">
            <summary>
            Write Logs or not
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.Transaction">
            <summary>
            Transaction Logger holds the 2ndary logger to text file.
            NOTE: this is set with the TransactionLogger param received
            on the Constructor.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.FileSet">
            <summary>
            Return the FileSet of the ObjectServer
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.TypeStore">
            <summary>
            Type Store is the typing system of the Server.
            It allows type registrationg and object instantiation based
            on registered type id
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.Filename">
            <summary>
            Filename returns the Server's System Filename
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.Name">
            <summary>
            Returns Filename as Name of this Entity
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.SystemFile">
            <summary>
            System File
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.LicenseKey">
            <summary>
            License Key
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.HasTrashBin">
            <summary>
            Set to false in order to turn off Trash Bin and save space.
            NOTE: HasTrashBin = false is only for Applications that
            don't intend to delete any item, e.g. - Document Indexing
            Applications.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.TrashBinType">
            <summary>
            Trash Bin Type.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.Size">
            <summary>
            Implement to return the number of bytes this persistent object will occupy in Persistence stream.
            Being able to return the size before writing the object's data bytes to stream is optimal
            for the "Packager". Implement this property if possible, else, implement and return -1 to tell
            the Packager the size is not available before this object is allowed to persist or save its data.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.ReadOnly">
            <summary>
            true will open the Files in Read Only mode, otherwise R/W.
            This is useful for Applications where they want to open SOP data
            files in Read only mode, not requiring Write access which is
            Admin friendly
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ObjectServer.HintSizeOnDisk">
            <summary>
            Return the size on disk(in bytes) of this object
            </summary>
        </member>
        <member name="T:Sop.OnDisk.ObjectServer.SystemFileSerializer">
            <summary>
            System File Serializer
            </summary>
        </member>
        <member name="T:Sop.SpecializedDataStore.PersistentTypeValueSimpleKey`2">
            <summary>
            Sorted Dictionary for:
            * Simple Key
            * IPersistent derived Value POCOs
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Sop.SpecializedDataStore.PersistentTypeValueSimpleKey`2.GetCollection(Sop.ISortedDictionaryOnDisk,Sop.GenericComparer{`0},System.String,System.Boolean)">
            <summary>
            Override SimpleKeyValue GetCollection to add support for IPersistent Value POCO (de)serialization.
            </summary>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="came"></param>
            <param name="isDataInKeySegment"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.DataBlock">
            <summary>
            DataBlock represents the smallest unit of data structure stored on disk.
            Each data block is linked to another data block within the same File
            forming a huge chain of structures on disk. Yes, a File in its simplest form,
            is mainly a series of linked data blocks in SOP. These structures may contain one or many
            Dictionaries on Disk (a.k.a. - data store).
            
            DataBlock is used in SOP for POCO persistence. i.e. - each POCO, internal or user defined,
            is serialized and data stored in a set of DataBlock objects which are then used by 
            file stream writers/readers in actual write/read of data to/from file on disk.
            
            Layout of a single data block on Disk:
            Byte 0 to 7: Logical level Next Item Address (64 bit long int)
            Byte 8 to 11: Size Occupied (32 bit)
            Byte 12 to 19: Physical or Low level next item address. (64 bit)
            Byt2 20: Count of member blocks if block is head.
            Byte 21 to Size Occupied: USER DATA
            </summary>
        </member>
        <member name="F:Sop.DataBlock.OverheadSize">
            <summary>
            Returns the number of bytes of overhead (non-user data or bytes used for mngmt) of a Block
            </summary>
        </member>
        <member name="M:Sop.DataBlock.#ctor(Sop.DataBlockSize)">
            <summary>
            Constructor expecting DataBlockSize.
            </summary>
            <param name="dataBlockSize"></param>
        </member>
        <member name="M:Sop.DataBlock.IsEmpty">
            <summary>
            Check if block is empty
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.IsBlockOfThis(System.Int64)">
            <summary>
            Is DataAddress one of this Sop.DataBlock's Blocks
            </summary>
            <param name="dataAddress"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.ClearData(System.Int32)">
            <summary>
            Clear the data contents without resetting the data address. This is useful
            for marking blocks of data on disk as cleared. Call "ClearData" then
            save the block to disk to set to 0 each data byte of the block(s) on disk.
            </summary>
        </member>
        <member name="M:Sop.DataBlock.ToString">
            <summary>
            Override of ToString to write the DataBlock's
            address (file offset) on disk.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.Initialize">
            <summary>
            Initialize this Data Block to its initial state
            </summary>
        </member>
        <member name="M:Sop.DataBlock.Create">
            <summary>
            Create Sop.DataBlock
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.Copy(Sop.DataBlock)">
            <summary>
            Copy this object to Destination
            </summary>
            <param name="destination"></param>
        </member>
        <member name="M:Sop.DataBlock.Clone">
            <summary>
            Clone this datablock
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.Extend">
            <summary>
            Extend the block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.GetSizeOccupied(System.Int32)">
            <summary>
            Get Total Size occupied by the chained Sop.DataBlock.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.GetBlock(System.Int32)">
            <summary>
            Retrieves a DataBlock from the chain.
            </summary>
            <param name="chainIndex">index or chain sequence # of the block to get from the chain.</param>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.GetData">
            <summary>
            Returns the entire blocks' data
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.CountMembers(System.Boolean)">
            <summary>
            Count number of in-memory members of the linked blocks.
            </summary>
            <param name="contiguousOnly">true will count contiguous blocks only, otherwise will count all member blocks.</param>
            <returns></returns>
        </member>
        <member name="M:Sop.DataBlock.ProcessHeadSets">
            <summary>
            Mark block as Head (IsHead=true) for each contiguous chain
            of 255 blocks. This allows mapping to disk to get optimized
            allowing bulk write/read of entire 255 chained block contents
            in one Read/Write IO async operation.
            </summary>
        </member>
        <member name="P:Sop.DataBlock.IsHead">
            <summary>
            true if this block is the head block, false otherwise.
            </summary>
        </member>
        <member name="P:Sop.DataBlock.Orphaned">
            <summary>
            true means this is candidate for recycling as there is no
            container that has reference on this block, false otherwise.
            </summary>
        </member>
        <member name="P:Sop.DataBlock.DataBlockSize">
            <summary>
            Set the data block size and create the Data byte array at same time
            </summary>
        </member>
        <member name="P:Sop.DataBlock.SizeOccupied">
            <summary>
            Size Occupied
            </summary>
        </member>
        <member name="P:Sop.DataBlock.DataAddress">
            <summary>
            Offset on Disk where start byte of Data is stored.
            NOTE: Internal use only.
            </summary>
        </member>
        <member name="P:Sop.DataBlock.InternalNextBlockAddress">
            <summary>
            Low-level Next block address, for internal use.
            </summary>
        </member>
        <member name="P:Sop.DataBlock.NextItemAddress">
            <summary>
            NextBlockAddress is used to link Blocks in order to accomodate Data bigger than
            what a Block can store (e.g., Data > 512 bytes).
            NOTE: Internal use only.
            </summary>
        </member>
        <member name="P:Sop.DataBlock.Data">
            <summary>
            Data to be persisted/read to/from store
            </summary>
        </member>
        <member name="P:Sop.DataBlock.IsDirty">
            <summary>
            Data is modified(true) or not(false).
            </summary>
        </member>
        <member name="P:Sop.DataBlock.Next">
            <summary>
            Returns next block.
            NOTE: Internal use only.
            </summary>
        </member>
        <member name="P:Sop.DataBlock.Length">
            <summary>
            Returns the Block's Size in bytes
            </summary>
        </member>
        <member name="P:Sop.DataBlock.SizeAvailable">
            <summary>
            returns how much data in bytes can still be appended to this datablock
            </summary>
        </member>
        <member name="T:Sop.Mru.MruItem">
            <summary>
            MRU Item
            </summary>
        </member>
        <member name="P:Sop.Mru.MruItem.Transaction">
            <summary>
            Transaction this block belongs to
            </summary>
        </member>
        <member name="T:Sop.ObjectServerWithTransaction">
            <summary>
            Object Server with transaction.
            </summary>
        </member>
        <member name="M:Sop.ObjectServerWithTransaction.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Sop.ObjectServerWithTransaction.#ctor(System.String,Sop.ITransaction,Sop.Preferences,System.Boolean)">
            <summary>
            Constructor expecting Filename and Transaction Logger
            </summary>
            <param name="filename"></param>
            <param name="transLogger"></param>
            <param name="profileScheme"> </param>
            <param name="readOnly"> </param>
        </member>
        <member name="M:Sop.ObjectServerWithTransaction.BeginTransaction">
            <summary>
            Begin Transaction
            </summary>
        </member>
        <member name="M:Sop.ObjectServerWithTransaction.Commit">
            <summary>
            Commit Transaction
            </summary>
        </member>
        <member name="M:Sop.ObjectServerWithTransaction.Rollback">
            <summary>
            Rollback the Transaction
            </summary>
        </member>
        <member name="M:Sop.ObjectServerWithTransaction.RollbackAll(System.String)">
            <summary>
            Rollback all pending transactions left open by previous Application run.
            </summary>
            <param name="serverRootPath"> </param>
        </member>
        <member name="T:Sop.QueryResult`1">
            <summary>
            Generic Query Result.
            </summary>
            <typeparam name="TKey"> </typeparam>
        </member>
        <member name="F:Sop.QueryResult`1.Found">
            <summary>
            true means the Key refered to by this instance was found,
            otherwise false
            </summary>
        </member>
        <member name="F:Sop.QueryResult`1.Key">
            <summary>
            Contains the Key of the Item to Search for
            </summary>
        </member>
        <member name="F:Sop.QueryResult`1.Value">
            <summary>
            Contains the Item's Value if it was found
            </summary>
        </member>
        <member name="M:Sop.QueryResult`1.Convert">
            <summary>
            Convert to non-generic QueryResult.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.QueryResult`1.Convert(Sop.QueryResult{`0}[])">
            <summary>
            Convert array of generic QueryResult into non-generic.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.QueryResult">
            <summary>
            Query Result.
            </summary>
        </member>
        <member name="F:Sop.QueryResult.Found">
            <summary>
            true means Key is found.
            </summary>
        </member>
        <member name="F:Sop.QueryResult.Value">
            <summary>
             Value of the matching item.
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.BTreeItem`2">
            <summary>
            In-Memory B-Tree Item
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.LinkedList.IListOnDisk">
            <summary>
            List On Disk interface
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.LinkedList.IListOnDisk.Item(System.Int32)">
            <summary>
            Address(ie - file offset) of this Object on Disk
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.IBTreeItemOnDisk">
            <summary>
            BTree Item On Disk interface
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.IBTreeItemOnDisk.Clone">
            <summary>
            Clone the item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.IBTreeItemOnDisk.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Pack the item
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.IBTreeItemOnDisk.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            Unpack the item
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.IBTreeItemOnDisk.HintSizeOnDisk">
            <summary>
            Hint for the Item's Size on disk
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.IBTreeItemOnDisk.IsDirty">
            <summary>
            true means item is dirty and needs to be written to disk,
            otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.IBTreeItemOnDisk.ValueLoaded">
            <summary>
            true means item is loaded, otherwise false
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.IndexedBlockRecycler">
            <summary>
            An efficient "indexed" DataBlockRecycler implementing 
            deleted blocks merging (to create a bigger reusable segment)
            when possible.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.DataBlock.IDataBlockRecycler">
            <summary>
            Data Block Recycler interface declares the methods
            necessary for implementation of a Data Block recycler
            algorithm
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockRecycler.AddAvailableBlock(System.Int64,System.Int64)">
            <summary>
            Add a freed up segment on disk to the list.
            NOTE: you can implement to detect abd combine 
            contiguous freed up segments
            into a bigger segment as necessary to reduce the 
            number of items managed
            </summary>
            <param name="dataAddress"></param>
            <param name="dataSize"></param>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockRecycler.GetAvailableBlock(System.Boolean,System.Int32,System.Int64@,System.Int64@)">
            <summary>
            Retrieves a freed up data block for allocation by the requesting code
            </summary>
            <param name="isRequesterRecycler"></param>
            <param name="requestedBlockSize"></param>
            <param name="dataAddress"></param>
            <param name="dataSize"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockRecycler.SetAvailableBlock(System.Int64,System.Int64,System.Int64)">
            <summary>
            Updates a freed up data segment either to reduce or expand it
            </summary>
            <param name="availableBlockAddress"></param>
            <param name="availableBlockNewAddress"></param>
            <param name="availableBlockNewSize"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockRecycler.RemoveAvailableBlock(System.Int64)">
            <summary>
            Remove a freed up data segment in the list.
            NOTE: caller code upon taking ownership (for allocation) 
            of a specific data segment can invoke this method to remove the segment from the list 
            </summary>
            <param name="dataAddress"></param>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockRecycler.Clear">
            <summary>
            Clear the freed up segments list
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.IDataBlockRecycler.Delete">
            <summary>
            For now, Delete is synonymous to Clear
            </summary>
        </member>
        <member name="P:Sop.OnDisk.DataBlock.IDataBlockRecycler.DataAddress">
            <summary>
            Address on Disk of the Data Block Recycler
            </summary>
        </member>
        <member name="P:Sop.OnDisk.DataBlock.IDataBlockRecycler.IsDeletedBlocksList">
            <summary>
            true means the recycler manages a Collection On Disk's
            list of deleted blocks
            </summary>
        </member>
        <member name="M:Sop.OnDisk.File.FileStream.Dispose">
            <summary>
            Dispose the File Stream.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.FileStream.Id">
            <summary>
            Returns in-memory ID of this file stream object.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.File.FileStream.RealStream">
            <summary>
            Returns the System.IO.FileStream object.
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.BTree.BTreeAlgorithm`2">
            <summary>
            BTreeAlgorithm is the core BTree class wrapper and implements BTree Collection interface.
            B-Tree data structure and algorithm are implemented in <see>"TreeNode"
                                                                     <cref>BTreeAlgorithm.TreeNode</cref>
                                                                   </see> class
            </summary>
        </member>
        <member name="F:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.DefaultSlotLength">
            <summary>
            In-memory B-Tree default slot length.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.#ctor(System.Byte)">
            <summary>
            Constructor to use if you want to provide the number of slots per node of the tree
            </summary>
            <param name="slotLen">number of slots per node</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.#ctor">
            <summary>
            Constructor to use if you want to use default number of slots per node (6)
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructor to use if you want to provide your own Comparer object that defines
            how your records will be sorted/arranged
            </summary>
            <param name="comparer">IComparer implementation that defines how records will be sorted</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.#ctor(System.Byte,System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructor to use if you want to provide number of slots per node and your comparer object
            </summary>
            <param name="slotLen">Number of slots per node</param>
            <param name="comparer">compare object defining how records will be sorted</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Clone">
            <summary>
            Returns a shallow copy of this BTreeAlgorithm
            </summary>
            <returns>Value of type BTreeAlgorithm</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Copy(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Implement to copy items from source onto this instance.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Remove(`0)">
            <summary>
            Remove "Item" from the tree. Doesn't throw exception if "Item" is not found
            </summary>
            <param name="key"> </param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Clear">
            <summary>
            Set to null all collected items and their internal buffers.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Search(`0)">
            <summary>
            Search btree for a certain record (Item). If current record is equal
            to Item then true will be returned without doing any search operation.
            This minimizes unnecessary BTree traversal. If Item is found, it becomes the current item.
            </summary>
            <param name="key"> </param>
            <returns>Returns true if found else, false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Search(`0,System.Boolean)">
            <summary>
            Search btree for a certain record (Item). If current record is equal
            to Item then true will be returned without doing any search operation.
            This minimizes unnecessary BTree traversal. If Item is found, it becomes the current item.
            </summary>
            <param name="key"> </param>
            <param name="goToFirstInstance">if true, will make first instance of duplicated keys the current record</param>
            <returns>Returns true if found else, false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.MoveFirst">
            <summary>
            Go to 1st item of the tree
            </summary>
            <returns>returns true if successful, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.MoveNext">
            <summary>
            Go to next item of the tree
            </summary>
            <returns>Returns true if successful, else, false. Also returns false if Current record is null.</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.MovePrevious">
            <summary>
            Go to previous item of the tree
            </summary>
            <returns>Returns true if successful, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.MoveLast">
            <summary>
            Go to last item of the tree. If there is no item, returns false.
            </summary>
            <returns>Returns true if successful, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Add(`0,`1)">
            <summary>
            Insert "Item" to the correct location in the tree. Tree is maintained to be balanced and sorted.
            Add and Delete methods cause Current Record to be invalid (set to null).
            </summary>
            <param name="key"> </param>
            <param name="value"> </param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Remove">
            <summary>
            Delete the current item from the tree. Tree is maintained to be balanced and sorted.
            </summary>
        </member>
        <member name="F:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Root">
            <summary>
            This holds the Root Node (parentmost) of the TreeNodes
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.SetCurrentItemAddress(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1}.TreeNode,System.Byte)">
            <summary>
            Utility function to assign/replace current item w/ a new item.
            </summary>
            <param name="itemNode">node of the new item</param>
            <param name="itemIndex">slot index of the new item</param>
        </member>
        <member name="P:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Count">
            <summary>
            Returns the number of collected items
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.CurrentEntry">
            <summary>
            Returns current item, null if end of Btree.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.SlotLength">
            <summary>
            Get: returns the number of slots per node of all "TreeNodes"
            Set: assigns the number of slots per node of "TreeNodes"
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.CurrentItem">
            <summary>
            This holds the Current Item Address (Current Node and Current Slot index)
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.Locker">
            <summary>
            Returns the object used for thread synchronization on multiple threads' access to this BTree object.
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode">
            <summary>
            TreeNode is where the actual B-Tree operation happens. Each object of TreeNode serves
            as the node of B-Tree tree
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.#ctor(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Protected Constructor. This is used to construct the root node of the tree.
            (has null parent)
            </summary>
            <param name="oBTree"></param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.#ctor(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1}.TreeNode)">
            <summary>
            Constructor expecting ParentTree and ParentNode params.
            This form is invoked from another instance of this class when node 
            splitting occurs. Normally, node split occurs to accomodate new items that
            could not be loaded to the node since the node is already full. 
            Calls <see cref="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Initialize(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1}.TreeNode)"/> to prepare class variables/objects
            </summary>
            <param name="parentTree">Parent B-Tree instance</param>
            <param name="parentNode">Parent Node instance</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.ResetArray``1(``0[],``0)">
            <summary>
            Reset all elements of the array to Value
            </summary>
            <param name="array">Array to reset all elements of</param>
            <param name="value">Value to assign to each element of the array</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Initialize(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1}.TreeNode)">
            <summary>
            Do class variable/object initialization. Usually invoked from this class' constructor.
            </summary>
            <param name="btree">Parent BTree</param>
            <param name="parentObj">Parent Node</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.MoveArrayElements``1(``0[],System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            "Shallow" move elements of an array. 
            "MoveArrayElements" moves a group (Count) of elements of an array from
            source index to destination index.
            </summary>
            <param name="array">Array whose elements will be moved</param>
            <param name="srcIndex">Source index of the 1st element to move</param>
            <param name="destIndex">Target index of the 1st element to move to</param>
            <param name="count">Number of elements to move</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.CopyArrayElements``1(``0[],System.UInt16,``0[],System.UInt16,System.UInt16)">
            <summary>
            "CopyArrayElements" copies elements of an array (Source) to destination array (Destination).
            </summary>
            <param name="source">Array to copy elements from</param>
            <param name="srcIndex">Index of the 1st element to copy</param>
            <param name="destination">Array to copy elements to</param>
            <param name="destIndex">Index of the 1st element to copy to</param>
            <param name="count">Number of elements to copy</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.ShiftSlots``1(``0[],System.Byte,System.Byte)">
            <summary>
            Skud over one slot all items to the right.
            The 1st element moved will then be vacated ready for an occupant.
            </summary>
            <param name="slots">"Slots" to skud over its contents</param>
            <param name="position">1st element index to skud over</param>
            <param name="noOfOccupiedSlots">Number of occupied slots</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Add(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},Sop.Collections.Generic.BTreeItem{`0,`1})">
            <summary>
            Recursive Add function. Actual addition of node item happens at the outermost level !
            </summary>
            <param name="parentBTree">Parent BTree</param>
            <param name="item">Item to add to the tree</param>
            <throws>Exception if No Comparer or Mem Alloc err is encountered.</throws>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Search(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},Sop.Collections.Generic.BTreeItem{`0,`1},System.Boolean)">
            <summary>
            Search BTreeAlgorithm for the item pointed to by Item. 
            NOTE: this should be invoked from root node.
            </summary>
            <param name="parentBTree">Parent BTree</param>
            <param name="item">Item to search in tree</param>
            <param name="goToFirstInstance">true tells BTree to go to First Instance of Key, else any key instance matching will match</param>
            <returns>true if item found, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Remove(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Remove the current item from the tree
            </summary>
            <param name="parentBTree">Parent BTree</param>
            <returns>Always returns true</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Clear(System.Boolean)">
            <summary>
            Clear the whole tree.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.MoveFirst(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Make the first item the current item. This member should be called from Root.
            </summary>
            <param name="parentBTree">BTree instance this Node is a part of</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.MoveNext(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Make the next item in the tree the current item.
            </summary>
            <param name="parentBTree">Parent BTree</param>
            <returns>true if successful, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.MovePrevious(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Make previous item in the tree current item.
            </summary>
            <param name="parentBTree">Parent BTree</param>
            <returns>true if successful, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.MoveLast(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Make the last item in the tree the current item.
            </summary>
            <param name="parentBTree">Parent BTree</param>
            <returns>true if successful, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.SetParent(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1}.TreeNode)">
            <summary>
            Make "NewParent" the parent of this Node.
            </summary>
            <param name="newParent">New Parent TreeNode</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.IsFull(System.Byte)">
            <summary>
            Returns true if slots are all occupied, else false
            </summary>
            <param name="slotLength">Number of slots per node</param>
            <returns>true if full, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.GetIndexOfNode(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Returns index of this node relative to parent. 
            Note: you must call this after you check that there is a parent node.
            </summary>
            <param name="parentBTree"> </param>
            <returns>Index of this node per its parent</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.GetLeftSibling(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Returns left sibling or null if finished traversing left nodes.
            </summary>
            <param name="parentBTree"> </param>
            <returns>Left sibling TreeNode reference</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.GetRightSibling(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Returns right sibling or null if finished traversing right nodes.
            </summary>
            <param name="parentBTree"> </param>
            <returns>Right sibling TreeNode reference</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.IsThereVacantSlotInLeft(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},System.Boolean@)">
            <summary>
            Returns true if a slot is available in left side siblings of this node modified to suit possible unbalanced branch.
            </summary>
            <param name="parentBTree">Parent BTree</param>
            <param name="isUnBalanced">Will be updated to true if this branch is detected to be "unbalanced", else false</param>
            <returns>true if there is a vacant slot, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.IsThereVacantSlotInRight(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},System.Boolean@)">
            <summary>
            Returns true if a slot is available in right side siblings of this node modified to suit possible unbalanced branch.
            </summary>
            <param name="parentBTree">Parent BTree</param>
            <param name="isUnBalanced">Will be updated to true if this branch is detected to be "unbalanced", else false</param>
            <returns>true if there is a vacant slot, else false</returns>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Promote(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},System.Byte)">
            <summary>
            This gets called when the node's slots are overflowed and break up
            is needed. This does the necessary recursive promotion of the 
            newly born nodes as affected by the break up.<br/>
            Uses caller Btree object's Temporary Slots and Children nodes
            which are accessible via GetTempSlot() and _GetTempParentChildren()
            as storage of Parent and newly born siblings.<br/><br/>
            NOTE: Uses Temporary Slots and Children nodes which are accessible via GetTempSlot() and _GetTempParentChildren() as storage of Parent and newly born siblings.
            </summary>
            <param name="parentBTree">parent BTree</param>
            <param name="position">Position of the broken apart node in its parent node's slots</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.DistributeToLeft(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},Sop.Collections.Generic.BTreeItem{`0,`1})">
            <summary>
            Distribute to left siblings the item if the current slots are  all filled up.
            Used when balancing the nodes' load of the current sub-tree.
            </summary>
            <param name="bTree"> </param>
            <param name="item">Item to distribute to left sibling node</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.DistributeToRight(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},Sop.Collections.Generic.BTreeItem{`0,`1})">
            <summary>
            Distribute to right siblings the item if the current slots are all filled up.
            Used when balancing the nodes' load of the current sub-tree.
            </summary>
            <param name="bTree"> </param>
            <param name="item">Item to distribute to right sibling</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.FixTheVacatedSlot(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Overwrite the current item with the item from the next or previous slot.
            Attempts to free the TreeNode object by setting Parent, Children and Slots to null.
            </summary>
            <param name="bTree">Parent BTree</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.PullFromLeft(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Recursively pull item from left side. Modified to process unbalanced branch - 10/31/97.
            Pull an item from the left siblings. Used when this node run out of loaded items and instead of destroying itself, will pull an item from the left siblings to maintain the balanceness of this sub-tree.
            </summary>
            <param name="bTree">Parent BTree</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.PullFromRight(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Recursively pull item from right side. Modified to process unbalanced branch - 10/31/97
            Same as above except that the pull is from the right siblings.
            </summary>
            <param name="bTree">Paren BTree</param>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.SearchForPullableItem(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1},System.Byte@)">
            <summary>
            Search for a pullable item from sibling nodes of this node. Modified for unbalanced branch's correct detection of pullable item. -10/31/97
            Find a pullable item. Will return true if there is one.
            </summary>
            <param name="parentBTree"> </param>
            <param name="index">Will be updated of the pullable item's index in the slot</param>
            <returns>true if there is pullable item, else false</returns>
        </member>
        <member name="F:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Slots">
            <summary>
            Slots of this TreeNode
            </summary>
        </member>
        <member name="F:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode._count">
            <summary>
            Count of items in this Node.
            </summary>
        </member>
        <member name="F:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Parent">
            <summary>
            Parent of this TreeNode
            </summary>
        </member>
        <member name="F:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.Children">
            <summary>
            Children of this TreeNode
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.ItemAddress">
            <summary>
            A BTreeAlgorithm's item address is composed of the node's address + the item's index in the Slots.
            </summary>
        </member>
        <member name="F:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.ItemAddress.Node">
            <summary>
            Node Reference (low-level is equivalent to Node Address)
            </summary>
        </member>
        <member name="F:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeNode.ItemAddress.NodeItemIndex">
            <summary>
            Index of the item in the Node's Slots
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeRootNode">
            <summary>
            The root node class. Encapsulates behavior specific to root nodes. 
            Also, since we support tree reuse, this adds attributes to support reuse.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeRootNode.#ctor(Sop.Collections.Generic.BTree.BTreeAlgorithm{`0,`1})">
            <summary>
            Constructor
            </summary>
            <param name="parentTree">Paren BTree</param>
        </member>
        <member name="F:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeRootNode.TreeCount">
            <summary>
            Get: returns the number of loaded items in the tree<br/>
            Set: assigns the number of loaded items in the tree
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.BTree.BTreeAlgorithm`2.TreeRootNode.Clear">
            <summary>
            Destroy all collected items and shell(slots) excluding the root shell. This renders the btree empty.
            </summary>
        </member>
        <member name="T:Sop.Collections.BTree.SystemDefaultComparer">
            <summary>
            BTree domain System default comparer. This comparer provides/uses System.Collections.Comparer.Default.Compare function.
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.SystemDefaultComparer.Compare(System.Object,System.Object)">
            <summary>
            Compare object x's key with object y's key.<br/>
            Returns:<br/>
            	&lt; 0 if x.Key is &lt; y.Key<br/>
            	&gt; 0 if x.Key &gt; y.Key<br/>
            	== 0 if x.Key == y.Key
            </summary>
            <param name="x">1st object whose key is to be compared</param>
            <param name="y">2nd object whose key is to be compared</param>
            <returns></returns>
        </member>
        <member name="T:Sop.Collections.BTree.IBTree">
            <summary>
            B-Tree interface defines the available members of B-Tree manager.
            Extends the following .Net Framework interfaces:
            System.Collections.IDictionary, System.Collections.ICollection, 
            System.Collections.IEnumerable,	System.ICloneable, 
            System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
            </summary>
        </member>
        <member name="T:Sop.Transaction.CommitPhase">
            <summary>
            Transaction Commit Phase
            </summary>
        </member>
        <member name="F:Sop.Transaction.CommitPhase.UnCommitted">
            <summary>
            Transaction is ongoing and uncommitted
            </summary>
        </member>
        <member name="F:Sop.Transaction.CommitPhase.FirstPhase">
            <summary>
            Transaction is in Phase 1 commit
            </summary>
        </member>
        <member name="F:Sop.Transaction.CommitPhase.SecondPhase">
            <summary>
            Transaction is in Phase 2 or committed state
            </summary>
        </member>
        <member name="F:Sop.Transaction.CommitPhase.Committed">
            <summary>
            Committed = Phase 2, Transaction was committed
            </summary>
        </member>
        <member name="F:Sop.Transaction.CommitPhase.Rolledback">
            <summary>
            Transaction was rolled back, changes were undone
            </summary>
        </member>
        <member name="T:Sop.Preferences">
            <summary>
            Use this to specify commonly settings to customize
            SOP behavior per performance and RAM/disk data allocations.
            </summary>
        </member>
        <member name="P:Sop.Preferences.MaxCollectionCount">
            <summary>
            Set this hint higher to reduce amount of memory SOP will use or set this
            smaller to increase memory use. More memory available to SOP will mean faster
            performance as more data objects will tend to be kept/stay accessible from memory,
            reduced page swap between disk and memory.
            </summary>
        </member>
        <member name="P:Sop.Preferences.CollectionSegmentSizeInKb">
            <summary>
            Data segment size on disk. Multiple POCOs can be stored
            in one segment, depending on POCO's serialized data size.
            This defaults to 
            </summary>
        </member>
        <member name="P:Sop.Preferences.DataBlockSize">
            <summary>
            Data Block size
            </summary>
        </member>
        <member name="P:Sop.Preferences.MemoryLimitInPercent">
            <summary>
            % RAM to use, leave 0 to let SOP manage mem-use.
            </summary>
        </member>
        <member name="P:Sop.Preferences.MaxStoreInstancePoolCount">
            <summary>
            Maximum number of Opened Data Stores in-memory.
            NOTE: When total number of opened and in-memory Stores 
            reach this amount, StoreFactory will start to auto-dispose
            least used opened Stores in-memory in order to maintain 
            memory/resource consumption within reasonable levels.
            </summary>
        </member>
        <member name="P:Sop.Preferences.MemoryExtenderMode">
            <summary>
            true will use disk to extend memory. Each new run will cleanup (delete!)
            previous run's data file.
            
            This mode is useful in some scenarios where application would like to
            extend memory capacity and data persistence is not important.
            </summary>
        </member>
        <member name="P:Sop.Preferences.Encoding">
            <summary>
            ObjectServer Character Encoding. Defaults to UTF-8.
            NOTE: once Encoding is defined, it can't be changed. Encoding is typically set 
            during creation of ObjectServer, once created, it can't be updated to another encoding.
            </summary>
        </member>
        <member name="P:Sop.Preferences.BTreeSlotLength">
            <summary>
            BTree Slot Length. Typical values are 12, 24, 48
            </summary>
        </member>
        <member name="P:Sop.Preferences.IsDataInKeySegment">
            <summary>
            Default value for the File's Collection's IsDataInKeySegment attribute.
            true means data is saved in Key segment, otherwise is saved on its own data segment.
            NOTE: this contains default value, your code can define a different IsDataInKeySegment
            value while retrieving data stores using StoreFactory.
            </summary>
        </member>
        <member name="P:Sop.Preferences.TrackStoreTypes">
            <summary>
            true will log user Store information as StoreFactory.Getxxx method is invoked.
            ObjectServer.StoreTypes table contains these information.
            </summary>
        </member>
        <member name="P:Sop.Preferences.TrashBinType">
            <summary>
            Trash Bin Type defaults to one bin per Collection.
            </summary>
        </member>
        <member name="T:Sop.OperationType">
            <summary>
            Collection operation types.
            </summary>
        </member>
        <member name="F:Sop.OperationType.Read">
            <summary>
            In Move, Search or Get current object/key/value operation.
            </summary>
        </member>
        <member name="F:Sop.OperationType.Write">
            <summary>
            In either Add, Update or Delete operation.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.HeaderData">
            <summary>
            Header Data contains the Collection's Header information
            such as start, end blocks, next allocatable block, count
            of items...
            </summary>
        </member>
        <member name="M:Sop.OnDisk.HeaderData.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Sop.OnDisk.HeaderData.#ctor(Sop.DataBlockSize)">
            <summary>
            Constructor expecting DataBlockSize
            </summary>
            <param name="dataBlockSize"></param>
        </member>
        <member name="F:Sop.OnDisk.HeaderData.RecycledSegment">
            <summary>
            Recycled _region
            </summary>
        </member>
        <member name="M:Sop.OnDisk.HeaderData.Clear">
            <summary>
            Clear the HeaderData member fields
            </summary>
        </member>
        <member name="F:Sop.OnDisk.HeaderData.StartAllocatableAddress">
            <summary>
            Start of allocatable address
            </summary>
        </member>
        <member name="F:Sop.OnDisk.HeaderData.NextAllocatableAddress">
            <summary>
            Next allocatable address
            </summary>
        </member>
        <member name="F:Sop.OnDisk.HeaderData.EndAllocatableAddress">
            <summary>
            End of allocatable address. When reached, a new block
            segment will be allocated by the Collection
            </summary>
        </member>
        <member name="F:Sop.OnDisk.HeaderData.OnDiskNextAvailableBlockAddress">
            <summary>
            Next available Sop.DataBlock address on Disk.
            NOTE: this is for internal use of the Transaction managers
            to keep tab of the next available block address
            </summary>
        </member>
        <member name="F:Sop.OnDisk.HeaderData.OnDiskLeftoverSegmentSize">
            <summary>
            On Disk Left over segment size.
            NOTE: for internal use only by the trans managers
            </summary>
        </member>
        <member name="M:Sop.OnDisk.HeaderData.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Serialize
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.HeaderData.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            DeSerialize
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="P:Sop.OnDisk.HeaderData.OccupiedBlocksHead">
            <summary>
            Occupied Blocks Head
            </summary>
        </member>
        <member name="P:Sop.OnDisk.HeaderData.OccupiedBlocksTail">
            <summary>
            Occupied Blocks Tail
            </summary>
        </member>
        <member name="P:Sop.OnDisk.HeaderData.Count">
            <summary>
            Returns the count of items stored in the Collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.HeaderData.DiskBuffer">
            <summary>
            HeaderData DiskBuffer override just set/get to disk buffer.
            </summary>
        </member>
        <member name="T:Sop.Recycling.Recycler`1">
            <summary>
            General purpose object recycler.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Sop.OnObjectUnpack">
            <summary>
            On Object Unpack event is invoked when User defined Object
            data is read from disk and SOP needs to DeSerialize it.
            User code is given chance to do its custom 
            DeSerialization of the Object from a given Stream
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.OnObjectPack">
            <summary>
            On Object Pack event is invoked when User defined Object
            needs to be Serialized to a Stream as preparation for persistence to Disk
            </summary>
            <param name="writer">Writer for a Target Stream</param>
            <param name="objectToPack">Object to be Serialized or Packed</param>
        </member>
        <member name="T:Sop.DataStoreType">
            <summary>
            Data Store types.
            
            NOTE: only SOP on disk store type is currently supported.
            Other type(s) will be supported depends on market demands as they arise.
            </summary>
        </member>
        <member name="F:Sop.DataStoreType.SopOndisk">
            <summary>
            SOP on Disk, default.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.IO.BulkWriter">
            <summary>
            Bulk Writer does a multi-threaded, asynchronous read/write operations
            for writing/reading big amount of data to/from target locations on disk.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.IO.BulkWriter.Write(Sop.OnDisk.Algorithm.Collection.ICollectionOnDisk,System.Byte[],System.Collections.Generic.List{Sop.OnDisk.IO.BulkWriter.DataChunk})">
            <summary>
            Write data to disk in bulk mode.
            This method can spin off multiple threads part of doing Asynchronous operations
            to accomplish following processes:
            - back up existing target data segments that will be overwritten to respective transaction log file.
            - overwrite target data segments with data from in-memory source provided (source parameter).
            </summary>
            <param name="parent"></param>
            <param name="source"></param>
            <param name="dataChunks"></param>
        </member>
        <member name="T:Sop.OnDisk.IO.BulkWriter.DataChunk">
            <summary>
            Signifies the data chunk from in-memory source (byte[]) that needs to be written to disk.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.IO.BulkWriter.DataChunk.TargetDataAddress">
            <summary>
            Target file offset where start of data chunk needs to be written.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.IO.BulkWriter.DataChunk.Index">
            <summary>
            Start of data chunk (from source) that needs to get written to disk.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.IO.BulkWriter.DataChunk.Size">
            <summary>
            Size of the data chunk that needs to get written to disk.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.DataBlock.DataBlockReadBufferLogic">
            <summary>
            Data Block Read ahead buffer logic.
            </summary>
        </member>
        <member name="T:Sop.Collections.BTree.ItemType">
            <summary>
            BTree item type enumeration
            </summary>
        </member>
        <member name="F:Sop.Collections.BTree.ItemType.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Sop.Collections.BTree.ItemType.Key">
            <summary>
            Key item type
            </summary>
        </member>
        <member name="F:Sop.Collections.BTree.ItemType.Value">
            <summary>
            Value item type
            </summary>
        </member>
        <member name="T:Sop.Collections.BTree.ChildNodes">
            <summary>
            Child nodes enumeration
            </summary>
        </member>
        <member name="F:Sop.Collections.BTree.ChildNodes.LeftChild">
            <summary>
            Left child
            </summary>
        </member>
        <member name="F:Sop.Collections.BTree.ChildNodes.RightChild">
            <summary>
            Right child
            </summary>
        </member>
        <member name="T:Sop.ObjectFactory">
            <summary>
            For internal use only.
            ObjectFactory is a utility class used to standardize in one
            place instantiation of SOP built-in entities such as Sorted Dictionary on Disk.
            </summary>
        </member>
        <member name="M:Sop.ObjectFactory.Reset">
            <summary>
            Reset singleton instance to default.
            </summary>
        </member>
        <member name="M:Sop.ObjectFactory.CreateDictionaryOnDisk(Sop.IFile,System.Collections.IComparer,System.String,System.Boolean)">
            <summary>
            Create Dictionary On Disk.
            </summary>
            <param name="file"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
            <returns></returns>
        </member>
        <member name="P:Sop.ObjectFactory.Instance">
            <summary>
            Singleton Instance
            </summary>
        </member>
        <member name="T:Sop.OnDisk.BuiltinTypes">
            <summary>
            Enumerates SOP Built-in types. Data Block Driver uses this
            list to be able to provide low-level deserialization for built-in
            types such as ArrayListOnDisk, LinkedListOnDisk, etc...
            Being able to deserialize low-level types is important, for example,
            for "bootup" types serialization.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.BTreeComparer">
            <summary>
            BTree domain System default comparer. This comparer provides/uses System.Collections.Comparer.Default.Compare function.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeComparer.Compare(System.Object,System.Object)">
            <summary>
            Compare object x's key with object y's key.<br/>
            Returns:<br/>
            	&lt; 0 if x.Key is &lt; y.Key<br/>
            	&gt; 0 if x.Key &gt; y.Key<br/>
            	== 0 if x.Key == y.Key
            </summary>
            <param name="x">1st object whose key is to be compared</param>
            <param name="y">2nd object whose key is to be compared</param>
            <returns></returns>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.BTreeDefaultComparer">
            <summary>
            BTree domain default comparer. This comparer provides numeric and string comparison behavior
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeDefaultComparer.Compare(System.Object,System.Object)">
            <summary>
            Compare string value of object x's key with object y's key<br/>
            Returns:<br/>
            	&lt; 0 if x.Key is &lt; y.Key<br/>
            	&gt; 0 if x.Key &gt; y.Key<br/>
            	== 0 if x.Key == y.Key
            </summary>
            <param name="x">1st object whose key is to be compared</param>
            <param name="y">2nd object whose key is to be compared</param>
            <returns></returns>
        </member>
        <member name="T:Sop.OnDisk.IO.AccessMode">
            <summary>
            Access Modes
            </summary>
        </member>
        <member name="F:Sop.OnDisk.IO.AccessMode.ReadOnly">
            <summary>
            Read Only
            </summary>
        </member>
        <member name="F:Sop.OnDisk.IO.AccessMode.ReadWrite">
            <summary>
            Read Write
            </summary>
        </member>
        <member name="T:Sop.Mru.Node">
            <summary>
            MRU Node.
            </summary>
        </member>
        <member name="T:Sop.Log.ILogger">
            <summary>
            General purpose Logger Interface.
            NOTE: this is mainly used for integrating to a log framework, e.g. - nLog or simple text logger,...
            </summary>
        </member>
        <member name="M:Sop.Log.ILogger.Log(Sop.Log.LogLevels,System.Exception,System.String,System.Object[])">
            <summary>
            Log an exception given log level (Error) with option for formatting and logging additional log text.
            </summary>
            <param name="logLevel"></param>
            <param name="exc"></param>
            <param name="messageFormat"></param>
            <param name="messageArgs"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Log.ILogger.Log(Sop.Log.LogLevels,System.String,System.Object[])">
            <summary>
            Log some text and returns its formatted string log value.
            </summary>
            <param name="logLevel"></param>
            <param name="messageFormat"></param>
            <param name="messageArgs"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Log.ILogger.IsLogLevelEnabled(Sop.Log.LogLevels)">
            <summary>
            Determines whether a log level is enabled or not.
            </summary>
            <param name="logLevel"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.Log.ILogger.Name">
            <summary>
            Name of this Logger.
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.ConcurrentSortedDictionary`2">
            <summary>
            In-Memory, duplicates allowed Concurrent (thread safe) Sorted Dictionary.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Sop.Collections.Generic.ISortedDictionary`2">
            <summary>
            In-Memory Sorted Dictionary interface.
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.IBaseCollection`1">
            <summary>
            In-Memory Base Collection
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.IBaseCollection`1.MoveNext">
            <summary>
            MoveNext makes the next entry current.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.IBaseCollection`1.MovePrevious">
            <summary>
            MovePrevious makes the previous entry current.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.IBaseCollection`1.MoveFirst">
            <summary>
            MoveFirst makes the first entry in the Collection current.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.IBaseCollection`1.MoveLast">
            <summary>
            MoveLast makes the last entry in the Collection current.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.IBaseCollection`1.Search(`0)">
            <summary>
            Search the Collection for existence of entry with a given key.
            </summary>
            <param name="key">key to search for.</param>
            <returns>true if found, false otherwise.</returns>
        </member>
        <member name="M:Sop.Collections.Generic.ISortedDictionary`2.EndOfTree">
            <summary>
            true if end of tree is reached (CurrentItem is null), otherwise false.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Collections.Generic.ISortedDictionary`2.Copy(Sop.Collections.Generic.ISortedDictionary{`0,`1})">
            <summary>
            Implement to copy items from source onto this instance.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Sop.Collections.Generic.ISortedDictionary`2.Remove">
            <summary>
            Remove an entry from Sorted Dictionary.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.ISortedDictionary`2.SortOrder">
            <summary>
            Returns current sort order. Setting to a different sort order will 
            reset BTree. First item according to sort order will be current item.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.ISortedDictionary`2.CurrentEntry">
            <summary>
            Returns the Current entry.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.ISortedDictionary`2.CurrentKey">
            <summary>
            Returns the Current entry's key.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.ISortedDictionary`2.CurrentValue">
            <summary>
            Returns the Current entry's Value.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.#ctor(System.Byte,System.Collections.Generic.IComparer{`0},Sop.SortOrderType)">
            <summary>
            Constructor to use if you want to provide number of slots per node and your comparer object
            </summary>
            <param name="slotLen">Number of slots per node</param>
            <param name="comparer">compare object defining how records will be sorted</param>
            <param name="sortOrder"> </param>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
                            </param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
                            </exception>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. 
                            </exception>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
                            </param>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.
                            </param><param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.
                            </param><exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.
                            </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.
                            </exception><exception cref="T:System.ArgumentException"><paramref name="array"/> is multidimensional.
                                -or-
                            <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
                                -or-
                                The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>.
                                -or-
                                Type <paramref name="T"/> cannot be cast automatically to the type of the destination <paramref name="array"/>.
                            </exception>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
                            </param><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
                            </exception>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Copy(Sop.Collections.Generic.ISortedDictionary{`0,`1})">
            <summary>
            Implement to copy items from source onto this instance.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
                            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
                            </exception>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.
                            </param><param name="value">The object to use as the value of the element to add.
                            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
                            </exception><exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
                            </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
                            </exception>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">The key of the element to remove.
                            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
                            </exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
                            </exception>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <returns>
            true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key whose value to get.
                            </param><param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value"/> parameter. This parameter is passed uninitialized.
                            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
                            </exception>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.MoveNext">
            <summary>
            MoveNext makes the next entry current.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.MovePrevious">
            <summary>
            MovePrevious makes the previous entry current.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.MoveFirst">
            <summary>
            MoveFirst makes the first entry in the Collection current.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.MoveLast">
            <summary>
            MoveLast makes the last entry in the Collection current.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Search(`0)">
            <summary>
            Search the Collection for existence of entry with a given key.
            </summary>
            <param name="key">key to search for.</param>
            <returns>true if found, false otherwise.</returns>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.EndOfTree">
            <summary>
            true if end of tree is reached (CurrentItem is null), otherwise false.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Remove">
            <summary>
            Remove an entry from Sorted Dictionary.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:Sop.Collections.Generic.ConcurrentSortedDictionary`2.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="P:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            <returns>
            The element with the specified key.
            </returns>
            <param name="key">The key of the element to get or set.
                            </param><exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.
                            </exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key"/> is not found.
                            </exception><exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.
                            </exception>
        </member>
        <member name="P:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="P:Sop.Collections.Generic.ConcurrentSortedDictionary`2.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="P:Sop.Collections.Generic.ConcurrentSortedDictionary`2.SortOrder">
            <summary>
            Returns current sort order. Setting to a different sort order will 
            reset BTree. First item according to sort order will be current item.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.ConcurrentSortedDictionary`2.CurrentEntry">
            <summary>
            Returns the Current entry.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.ConcurrentSortedDictionary`2.CurrentKey">
            <summary>
            Returns the Current entry's key.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.ConcurrentSortedDictionary`2.CurrentValue">
            <summary>
            Returns the Current entry's Value.
            </summary>
        </member>
        <member name="T:Sop.Utility.Win32">
            <summary>
            Win 32 I/O API interop declarations.
            </summary>
        </member>
        <member name="M:Sop.Utility.Win32.GetMemorySize">
            <summary>
            Returns the total physical memory (RAM) size of this host.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Utility.Win32.GetDriveSectorSize(System.String)">
            <summary>
            Return the sector size of the volume the specified filepath lives on.
            </summary>
            <param name="path">UNC path name for the file or directory</param>
            <returns>device sector size in bytes </returns>
        </member>
        <member name="M:Sop.Utility.Win32.UnbufferedOpen(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Given a path and mode/sharing/etc flags, open a file in un-buffered mode.
               (i.e. NTFS is told not to cache the file contents).
            </summary>
            <param name="path">File name</param>
            <param name="mode"> System.IO.FileMode </param>
            <param name="acc">System.IO.FileAccess: Read | Write | ReadWrite</param>
            <param name="share">System.IO.FileShare</param>
            <param name="sequential">sequential file access</param>
            <param name="async">async file access</param>
            <param name="blockSize">block size in bytes</param>
            <returns>Unbuffered file stream.</returns>
        </member>
        <member name="T:Sop.ObjectServer">
            <summary>
            Object Server wrapper class.
            All methods delegate to the real Object Server received as a parameter in one of the ctors.
            </summary>
        </member>
        <member name="F:Sop.ObjectServer.DefaultFileExtension">
            <summary>
            Returns the default file extension of the Object Server
            </summary>
        </member>
        <member name="M:Sop.ObjectServer.#ctor">
            <summary>
            default ctor.
            </summary>
        </member>
        <member name="M:Sop.ObjectServer.#ctor(Sop.IObjectServer)">
            <summary>
            ctor receiving the real object server as parameter.
            </summary>
            <param name="server"></param>
        </member>
        <member name="M:Sop.ObjectServer.BeginTransaction">
            <summary>
            Begin a new Transaction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.ObjectServer.Commit">
            <summary>
            Commit Transaction
            </summary>
        </member>
        <member name="M:Sop.ObjectServer.Rollback">
            <summary>
            Rollback the Transaction
            </summary>
        </member>
        <member name="M:Sop.ObjectServer.OpenReadOnly(System.String)">
            <summary>
            Open in read only mode.
            </summary>
            <param name="serverFilename">Filename of Object Server to open in read only mode.</param>
            <returns></returns>
        </member>
        <member name="M:Sop.ObjectServer.OpenReadOnly(System.String,Sop.Preferences)">
            <summary>
            Open Object Server in read only mode.
            </summary>
            <param name="serverFilename"></param>
            <param name="serverProfile"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.ObjectServer.OpenWithTransaction(System.String)">
            <summary>
            Open Object Server and begin a lightweight (high speed!) SOP transaction.
            </summary>
            <param name="serverFilename"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.ObjectServer.OpenWithTransaction(System.String,Sop.Preferences)">
            <summary>
            Open Object Server and begin a low-level SOP transaction (transaction with no-ACID properties).
            </summary>
            <param name="serverFilename"></param>
            <param name="serverProfile"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.ObjectServer.RollbackAll(System.String)">
            <summary>
            Rollback all pending transactions left open by previous Application run.
            </summary>
        </member>
        <member name="P:Sop.ObjectServer.LicenseKey">
            <summary>
            License Key.
            </summary>
        </member>
        <member name="P:Sop.ObjectServer.MaxFileStreamInstanceCount">
            <summary>
            Maximum number of File Stream Instance count.
            
            NOTE: SOP manages File Stream instances so when total number of
            Opened File Streams reaches maximum amount, SOP will close down
            least recently used File Stream. This management is important for 
            scalability as File Streams are expensive resources, OS imposes
            maximum limit and .
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk">
            <summary>
            SortedDictionaryOnDisk uses balanced m-way tree (B-Tree) algorithm.
            </summary>
            <summary>
            BTree In Disk. Objects will be saved using Binary (De)Serialization
            to take advantage of this fast serialization method. Value(s)
            are recommended to implement ISerialize interface in order to control
            what and how their data will be saved.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.#ctor(Sop.OnDisk.File.IFile)">
            <summary>
            Constructor
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.#ctor(Sop.OnDisk.File.IFile,System.Collections.IComparer)">
            <summary>
            Constructor
            </summary>
            <param name="file"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.#ctor(Sop.OnDisk.File.IFile,System.Collections.IComparer,System.String,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="file"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"> </param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.IsItMe(Sop.OnDisk.Algorithm.Collection.CollectionOnDisk)">
            <summary>
            Is the other collection logically(their item container are the same) this Collection.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Dispose">
            <summary>
            Dispose this Sorted Dictionary from memory. NOTE: data on disk are not removed.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.ReadFromBlock(Sop.DataBlock)">
            <summary>
            Recreate/DeSerialize the object from source Sop.DataBlock
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.GetParent(System.Type)">
            <summary>
            Traverse the Parent hierarchy and look for a Parent of a given Type.
            Example, one can look for the "File" container of a Collection or a Parent
            Collection of a Collection and so on and so forth..
            </summary>
            <param name="parentType"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.RegisterChange(System.Boolean)">
            <summary>
            Register Change to Transaction so rollback can undo changes
            during rollback.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Search(System.Object,System.Boolean)">
            <summary>
            Search B-Tree for an item with Key
            </summary>
            <param name="key"></param>
            <param name="goToFirstInstance">Go to 1st key instance if the key has duplicate</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Search(System.Object,System.Int64)" -->
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Search(System.Object)">
            <summary>
            Search item with Key, passing false to GotoFirstInstance
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.EndOfTree">
            <summary>
            Returns true if current record pointer is beyond last item in tree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Flush">
            <summary>
            Save the Dictionary On Disk
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.GetNextSequence">
            <summary>
            Go to Next Sequence and return it
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Serialize this Tree
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            DeSerialize this Tree
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.UserData">
            <summary>
            User assigned data that isn't serialized to DB
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Clear">
            <summary>
            Clears contents of this Collection
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Delete">
            <summary>
            Delete the tree and send its blocks for recycling
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.MoveFirst">
            <summary>
            Move pointer to 1st item in tree
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.MovePrevious">
            <summary>
            Move pointer to previous item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.MoveLast">
            <summary>
            Move pointer to last item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.MoveNext">
            <summary>
            Move pointer to next item
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.GetEnumerator">
            <summary>
            Returns an Enumerator used for traversing the tree
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.ToString">
            <summary>
            ToString returns a globally unique name of this Collection on Disk.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.UniqueStoreName">
            <summary>
            Unique Store Name.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.GetCurrentValue(Sop.Persistence.IPersistent)">
            <summary>
            Get the Current Item's Value.
            NOTE: call one of the Move functions or the Search/Contains 
            function to position the Item pointer to the one you are interested
            about(Key) then call GetCurrentValue to get the Item Value
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.GetValue(System.Object,Sop.Persistence.IPersistent)">
            <summary>
            Get the Item's Value given a Key.
            </summary>
            <param name="key">key of entry whose value will be retrieved</param>
            <param name="target">target is the </param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Remove(System.Object)">
            <summary>
            Remove item with key from tree
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Remove">
            <summary>
            Remove currently selected item from tree
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Rename(System.String)">
            <summary>
            Rename this Sorted Dictionary
            </summary>
            <param name="newName"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Contains(System.Object)">
            <summary>
            true if key is found, otherwise false
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Add(System.Object,System.Object)">
            <summary>
            Add Object to target store
            </summary>
            <param name="key">key of object</param>
            <param name="value">object to be saved</param>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.ItemType">
            <summary>
            Item type BTree will store. Defaults to 'Default' Item type
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Clone">
            <summary>
            Make another copy of this collection,
            e.g. - useful for implementing enumerators
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Load">
            <summary>
            Load the Collection from disk. NOTE: items are not loaded
            to memory, but just the meta info so client code can iterate
            items, get or do management action(add, delete)
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Open">
            <summary>
            Open the collection if not opened yet
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Close">
            <summary>
            Close the collection if not yet closed
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.GetId">
            <summary>
            Returns the ID of the collection on disk
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.SetId(System.Int64)">
            <summary>
            Update the ID of the collection on disk
            </summary>
            <param name="address"></param>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.IsValueInStream">
            <summary>
            Returns true if Value is in Binary Reader Stream (OnDiskBinaryReader),
            otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.ParentTransactionLogger">
            <summary>
            For SOP Internal use only.
            ParentTransactionLogger gets/sets the parent transaction logger
            of this Collection.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.StreamReader">
            <summary>
            Stream Reader
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.MruManager">
            <summary>
            MRU cache manager
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.IsDirty">
            <summary>
            IsDirty tells BTree whether this object needs to be rewritten to disk(dirty) or not
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.ChangeRegistry">
            <summary>
            true if Change Registry is enabled, otherwise false.
            If false, any changes(add,remove) to the B-Tree collection
            will not roll back. This is for SOP internal use only
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.CurrentEntryDataAddress">
            <summary>
            Address on disk of current entry's data
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Parent">
            <summary>
            Parent of this object can be another Collection or File object.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.CurrentKey">
            <summary>
            Returns current item's key
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.CurrentItemOnDisk">
            <summary>
            Returns current item on disk
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Container">
            <summary>
            Container of this instance
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.CurrentValue">
            <summary>
            Current item value
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.SortOrder">
            <summary>
            SortOrder can be ascending or descending
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.HintSequentialRead">
            <summary>
            Before doing a sequential read, set this to true and false
            when done doing seq read. Knowing such a Hint, SOP can
            optimize disk I/O.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.HintSizeOnDisk">
            <summary>
            Return the size on disk(in bytes) of this object
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.HintKeySizeOnDisk">
            <summary>
            Hint: Key size on disk(in bytes)
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.HintValueSizeOnDisk">
            <summary>
            Hint: Value size on disk(in bytes)
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.CurrentSequence">
            <summary>
            Returns Current Sequence Number
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.CurrentEntry">
            <summary>
            Return Currenty Entry(Key/Value)
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.IsReadOnly">
            <summary>
            true if dictionary is read only, otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Transaction">
            <summary>
            Transaction Logger
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Item(System.Object)">
            <summary>
            default accessor "this".
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.RootNode">
            <summary>
            Returns the Root Node of the B-Tree
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.CurrentNode">
            <summary>
            Returns the Current Node of the B-Tree
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Values">
            <summary>
            Returns Objects in the collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DataBlockDriver">
            <summary>
            Returns Sop.DataBlock Driver
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.IsOpen">
            <summary>
            true if collection is open, otherwise false
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Keys">
            <summary>
            Returns the Keys of Objects in the collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.IsFixedSize">
            <summary>
            true if collection is fixed size or not (false)
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Count">
            <summary>
            Returns the count of Objects in collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.OnDiskBinaryReader">
            <summary>
            Returns the OnDiskBinaryReader
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DataAddress">
            <summary>
            DataAddress of the collection on disk
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Name">
            <summary>
            Name of the collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.File">
            <summary>
            File where collection lives
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.FileStream">
            <summary>
            FileStream of the collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.Size">
            <summary>
            Implement to return the number of bytes this persistent object will occupy in Persistence stream.
            Being able to return the size before writing the object's data bytes to stream is optimal
            for the "Packager". Implement this property if possible, else, implement and return -1 to tell
            the Packager the size is not available before this object is allowed to persist or save its data.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DiskBuffer">
            <summary>
            DiskBuffer of collection
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.IndexBlockSize">
            <summary>
            Index blocksize
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DataBlockSize">
            <summary>
            Data Blocksize
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.AutoDisposeItem">
            <summary>
            Auto Dispose Item when this Store removes it from Cache (and saves to disk) or when the item gets deleted.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.AutoDispose">
            <summary>
            Auto Dispose this Store when it gets removed from the container's cache.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DictionaryEnumerator">
            <summary>
            The B-Tree enumerator
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DictionaryEnumerator.#ctor(Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk)">
            <summary>
            Constructor. Pass the B-Tree instance you want to enumerate its items/elements on.
            </summary>
            <param name="bTree">BTree instance items will be enumerated</param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DictionaryEnumerator.MoveNext">
            <summary>
            Make the next record current
            </summary>
            <returns>Returns true if successul, false otherwise</returns>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DictionaryEnumerator.Reset">
            <summary>
            Reset enumerator. You will need to call MoveNext to get to first record.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DictionaryEnumerator.Entry">
            <summary>
            Returns current BTree entry/record
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DictionaryEnumerator.Key">
            <summary>
            Returns Key of the current record
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DictionaryEnumerator.Value">
            <summary>
            Returns Value of the current record
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk.DictionaryEnumerator.Current">
            <summary>
            Returns Current record
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws InvalidOperationException exception if Reset was called without calling MoveNext</exception>
        </member>
        <member name="T:Sop.Persistence.Persistent">
            <summary>
            Extend/implement Persistent base class to provide
            custom serialization methods for persistence. You can 
            define or control saving/reading of raw bytes of 
            individual fields to/from a given persistence stream
            </summary>
        </member>
        <member name="M:Sop.Persistence.Persistent.Pack(System.IO.BinaryWriter)">
            <summary>
            Serialize this Object onto the Stream using a Writer
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.Persistence.Persistent.Unpack(System.IO.BinaryReader)">
            <summary>
            DeSerialize this Object from Stream using a Reader
            </summary>
            <param name="reader"></param>
        </member>
        <member name="P:Sop.Persistence.Persistent.IsDisposed">
            <summary>
            Implement to return true if object can be Disposed.
            NOTE: If in Disposed state (true) and it still 
            resides in SOP buffers, next time it gets retrieved,
            SOP will reload it from Disk.
            Return false if your object isn't Disposable and doesn't
            need to reload from disk
            </summary>
        </member>
        <member name="P:Sop.Persistence.Persistent.HintSizeOnDisk">
            <summary>
            Implement to tell SOP Container the actual/maximum size of your Object in bytes.
            Return 0 if your code can't calculate or doesn't know the size before hand.
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.SortedDictionary`2">
            <summary>
            In-Memory, duplicates allowed Sorted Dictionary.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructor to use if you want to provide your own Comparer object that defines
            how your records will be sorted/arranged
            </summary>
            <param name="comparer">IComparer implementation that defines how records will be sorted</param>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.#ctor(System.Byte)">
            <summary>
            Constructor to use if you want to provide the number of slots per node of the tree
            </summary>
            <param name="slotLen">number of slots per node</param>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.#ctor">
            <summary>
            Constructor to use if you want to use default number of slots per node (6)
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.#ctor(System.Byte,System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructor to use if you want to provide number of slots per node and your comparer object
            </summary>
            <param name="slotLen">Number of slots per node</param>
            <param name="comparer">compare object defining how records will be sorted</param>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.Copy(Sop.Collections.Generic.ISortedDictionary{`0,`1})">
            <summary>
            Copy all items from source onto this instance.
            NOTE: it is assumed that this instance's Comparer is compatible with source's.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.Add(`0,`1)">
            <summary>
            Add adds an entry with the provided key and value into the BTree.
            Duplicate keys are allowed in BTree unlike in a Dictionary/HashTable
            where key is required to be unique.
            </summary>
            <param name="key">key of item you want to add to the collection</param>
            <param name="value">item you want to add to the collection</param>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Contains determines whether this collection contains an entry with the specified key.
            </summary>
            <param name="item"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.Remove(`0)">
            <summary>
            Removes entry with key.
            </summary>
            <param name="key">key of entry to delete from collection</param>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.Remove">
            <summary>
            Delete currently selected entry of BTree
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.SortedDictionary`2.SortOrder">
            <summary>
            Returns current sort order. Setting to a different sort order will 
            reset BTree. First item according to sort order will be current item.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.SortedDictionary`2.Item(`0)">
            <summary>
            BTree indexer. Given a key, will return its value.
            If key is not found, will add a new entry having passed 
            params key and value.
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.SortedDictionary`2.BTreeEnumerator`1">
            <summary>
            The B-Tree enumerator
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.BTreeEnumerator`1.#ctor(Sop.Collections.Generic.ISortedDictionary{`0,`1})">
            <summary>
            Constructor. Pass the B-Tree instance you want to enumerate its items/elements on.
            </summary>
            <param name="bTree">BTree instance items will be enumerated</param>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.BTreeEnumerator`1.MoveNext">
            <summary>
            Make the next record current
            </summary>
            <returns>Returns true if successul, false otherwise</returns>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.BTreeEnumerator`1.Reset">
            <summary>
            Reset enumerator. You will need to call MoveNext to get to first record.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.SortedDictionary`2.BTreeEnumerator`1.Current">
            <summary>
            Returns Current record
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws InvalidOperationException exception if Reset was called without calling MoveNext</exception>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.BTreeEnumeratorValue.#ctor(Sop.Collections.Generic.ISortedDictionary{`0,`1})">
            <summary>
            Constructor. Pass the B-Tree instance you want to enumerate its items/elements on.
            </summary>
            <param name="bTree">BTree instance items will be enumerated</param>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.BTreeEnumeratorKey.#ctor(Sop.Collections.Generic.ISortedDictionary{`0,`1})">
            <summary>
            Constructor. Pass the B-Tree instance you want to enumerate its items/elements on.
            </summary>
            <param name="bTree">BTree instance items will be enumerated</param>
        </member>
        <member name="M:Sop.Collections.Generic.SortedDictionary`2.BTreeEnumeratorDefault.#ctor(Sop.Collections.Generic.ISortedDictionary{`0,`1})">
            <summary>
            Constructor. Pass the B-Tree instance you want to enumerate its items/elements on.
            </summary>
            <param name="bTree">BTree instance items will be enumerated</param>
        </member>
        <member name="T:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk">
            <summary>
            B-Tree Item on Disk.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk.Clone">
            <summary>
            Create a shallow copy of this object
            </summary>
            <returns></returns>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk.Key">
            <summary>
            Key
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk.VersionNumber">
            <summary>
            Version Number of the Item
            </summary>
        </member>
        <member name="F:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk.Value">
            <summary>
            Value. When Value is updated, IsDirty is set to true.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Pack this Item for serialization to disk
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            Unpack this item for DeSerialization from Stream
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk.IsDirty">
            <summary>
            IsDirty tells BTree whether this object needs to be rewritten to disk(dirty) or not
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk.ValueLoaded">
            <summary>
            true means Value was loaded from Disk, false otherwise. Defaults to true.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.Algorithm.BTree.BTreeItemOnDisk.HintSizeOnDisk">
            <summary>
            Return the size on disk(in bytes) of this object
            </summary>
        </member>
        <member name="T:Sop.OnDisk.CachePoolManager">
            <summary>
            Cache Pool Manager.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.CachePoolManager.Initialize(System.Int32,System.Int32)">
            <summary>
            Initialize Cache Pool Manager.
            </summary>
            <param name="mruMinCapacity"></param>
            <param name="mruMaxCapacity"></param>
        </member>
        <member name="M:Sop.OnDisk.CachePoolManager.GetCache(System.String)">
            <summary>
            Get collection cache given an Id.
            </summary>
            <param name="cacheId"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.CachePoolManager.SetCache(System.String,Sop.OnDisk.Algorithm.Collection.ICollectionCache)">
            <summary>
            Updates a collection cache with a given cache Id.
            </summary>
            <param name="cacheId"></param>
            <param name="cache"></param>
        </member>
        <member name="T:Sop.SpecializedDataStore.GeneralPurpose`2">
            <summary>
            General Purpose Data Store.
            </summary>
            <typeparam name="TKey">Any of the supported simple types or any Xml Serializable type.</typeparam>
            <typeparam name="TValue">Any of the supported simple types or any Xml Serializable type.</typeparam>
        </member>
        <member name="M:Sop.SpecializedDataStore.GeneralPurpose`2.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Sop.SpecializedDataStore.GeneralPurpose`2.#ctor(System.Object,System.String)">
            <summary>
            Constructor expecting container instance and name of the Data Store.
            </summary>
            <param name="container">Container data store this data store instance is an item of.</param>
            <param name="name">Name of this data store.</param>
        </member>
        <member name="M:Sop.SpecializedDataStore.GeneralPurpose`2.#ctor(System.Object,System.Collections.Generic.IComparer{`0},System.String)">
            <summary>
            Constructor expecting container instance, a comparer and name of the Data Store.
            </summary>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
        </member>
        <member name="M:Sop.SpecializedDataStore.GeneralPurpose`2.GetCollection(Sop.ISortedDictionaryOnDisk,Sop.GenericComparer{`0},System.String,System.Boolean)">
            <summary>
            Override SimpleKeyValue GetCollection to add support for key/value POCO Xml (de)serialization support.
            </summary>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.OnDisk.DataBlock.DeletedBlockInfo">
            <summary>
            Deleted Block Info can contain two types of data:
            1) Selective Delete blocks: Start Address and Count of deleted contiguous blocks
            2) Entire Collection blocks: Start and End Blocks of the deleted collection
            </summary>
        </member>
        <member name="F:Sop.OnDisk.DataBlock.DeletedBlockInfo.StartBlockAddress">
            <summary>
            1.) Start Address of deleted contiguous blocks, OR
            2.) Start block Address of deleted collection
            </summary>
        </member>
        <member name="F:Sop.OnDisk.DataBlock.DeletedBlockInfo.EndBlockAddress">
            <summary>
            1.) NA
            2.) End Address of deleted collection
            </summary>
        </member>
        <member name="F:Sop.OnDisk.DataBlock.DeletedBlockInfo.Count">
            <summary>
            1.) Count of deleted Blocks
            2.) NA
            </summary>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DeletedBlockInfo.Pack(Sop.Persistence.IInternalPersistent,System.IO.BinaryWriter)">
            <summary>
            Serialize
            </summary>
            <param name="parent"></param>
            <param name="writer"></param>
        </member>
        <member name="M:Sop.OnDisk.DataBlock.DeletedBlockInfo.Unpack(Sop.Persistence.IInternalPersistent,System.IO.BinaryReader)">
            <summary>
            DeSerialize
            </summary>
            <param name="parent"></param>
            <param name="reader"></param>
        </member>
        <member name="P:Sop.OnDisk.DataBlock.DeletedBlockInfo.IsContiguousBlock">
            <summary>
            true if contiguous block (ie - Count contains number of reusable blocks),
            otherwise, contains linked blocks. EndBlockAddress contains last deleted block.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.DataBlock.DeletedBlockInfo.HintSizeOnDisk">
            <summary>
            Return the size on disk(in bytes) of this object
            </summary>
        </member>
        <member name="P:Sop.OnDisk.DataBlock.DeletedBlockInfo.DiskBuffer">
            <summary>
            DiskBuffer of this DeletedBlockInfo
            </summary>
        </member>
        <member name="P:Sop.OnDisk.DataBlock.DeletedBlockInfo.IsDirty">
            <summary>
            true means this DeletedBlockInfo was modified, otherwise false
            </summary>
        </member>
        <member name="T:Sop.SortOrderType">
            <summary>
            Traversal/sort order enum
            </summary>
        </member>
        <member name="F:Sop.SortOrderType.Ascending">
            <summary>
            Sort order is ascending.
            </summary>
        </member>
        <member name="F:Sop.SortOrderType.Descending">
            <summary>
            Sort order is descending.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.IO.OnDiskBinaryWriter">
            <summary>
            OnDiskBineryWriter overrides BinaryWriter to write basic data types
            to target DataBlock(s)
            </summary>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.#ctor(System.Text.Encoding)">
            <summary>
            Constructor expecting Encoding for use while Writing
            </summary>
            <param name="encoding"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.String)">
            <summary>
            Write a string Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Single)">
            <summary>
            Write a float Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.UInt64)">
            <summary>
            Write an unsigned long Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Int64)">
            <summary>
            Write a long Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.UInt32)">
            <summary>
            Write an unsigned int Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Int32)">
            <summary>
            Write an int Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.UInt16)">
            <summary>
            Write an unsigned short Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Int16)">
            <summary>
            Write short Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Decimal)">
            <summary>
            Write a decimal Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Double)">
            <summary>
            Write a double Value
            </summary>
            <param name="Value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            Write a char array
            </summary>
            <param name="chars"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Char[])">
            <summary>
            Write a char array
            </summary>
            <param name="chars"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Char)">
            <summary>
            Write a char
            </summary>
            <param name="ch"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a byte array
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Byte[])">
            <summary>
            Write a byte array
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.SByte)">
            <summary>
            Write a signed byte
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Byte)">
            <summary>
            Write a byte
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Write(System.Boolean)">
            <summary>
            Write a boolean Value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.WriteAsXml(System.Xml.Serialization.XmlSerializer,System.Object)">
            <summary>
            Serialize an Object to Xml. NOTE: object should be Xml Serializable
            </summary>
            <param name="serializer"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.WriteRawData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Serialize an Object to Xml. NOTE: object should be Xml Serializable
            </summary>
            <param name="serializer"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.WriteObject(Sop.OnDisk.File.IFile,System.Object,Sop.DataBlock)">
            <summary>
            Serialize an Object to the target DataBlock
            </summary>
            <param name="file"></param>
            <param name="value"></param>
            <param name="dataBlock"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryWriter.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Moves the Stream Pointer to a given Offset relative to the Origin
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="P:Sop.OnDisk.IO.OnDiskBinaryWriter.DataBlock">
            <summary>
            get/set the target DataBlock. All Data writes will
            write to the target Block(s). OnDiskBinaryWriter takes
            care of dividing the data for write across 1 or more
            DataBlocks as needed.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.IO.OnDiskBinaryWriter.DataBlockPosition">
            <summary>
            Index in Data Block where next item will be written.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.IO.OnDiskBinaryWriter.LogicalPosition">
             <summary>
             Returns the actual byte location of the stream pointer in the logical stream.
            
             NOTE: BaseStream.Position can return different value than LogicalPosition as
             this implementation resets/empties the BaseStream at times necessary to conserve
             memory. Intent is to write data to the target DataBlock(s) and it's discretion of
             code whether to truncate the BaseStream or not to conserve memory.
            
             LogicalPosition then serves the purpose of tracking and returning the actual
             total count of bytes written to the "stream".
             </summary>
        </member>
        <member name="T:Sop.OnDisk.IO.OnDiskBinaryReader">
            <summary>
            OnDiskBinaryReader is a BinaryReader for reading basic data types
            from DataBlock(s)
            </summary>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryReader.#ctor(System.Text.Encoding)">
            <summary>
            Constructor expecting Encoding to use while reading data
            </summary>
            <param name="encoding"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryReader.ReadPersistent(Sop.DataBlock)">
            <summary>
            Read InternalPersistent Value returns the Data (byte array) of a previously saved InternalPersistent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryReader.ReadBytes(Sop.DataBlock)">
            <summary>
            Useful if wanting to DeSerialize back into IInternalPersistent type of object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryReader.ReadObject(Sop.DataBlock)">
            <summary>
            Caller code need to provide the Value Type. Plan is Collection Manager will persist Type name
            of the Value it supports, then during reading, will use the persisted Type name and get the 
            Type from Types Collection.
            </summary>
            <param name="dataBlock"> </param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryReader.ReadFromXml(System.Xml.Serialization.XmlSerializer)">
            <summary>
            Serialize an Object to Xml. NOTE: object should be Xml Serializable
            </summary>
            <param name="serializer"></param>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryReader.ReadRawData(System.Int32@)">
            <summary>
            Read raw data from stream. This is useful to provide code
            capability to get raw data and do its own deserialization.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.IO.OnDiskBinaryReader.ReadRawData(System.Byte[],System.Int32@)">
            <summary>
            Read raw data from stream. This is useful to provide code
            capability to get raw data and do its own deserialization.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sop.OnDisk.IO.OnDiskBinaryReader.DataBlock">
            <summary>
            Set a DataBlock will write the Block's data byte array into this object's
            Memory Stream.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.IO.ConcurrentIOData">
            <summary>
            Data entity used for doing a highly optimized,
            events based concurrent I/O.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.IO.ConcurrentIOData.Filename">
            <summary>
            Filename
            </summary>
        </member>
        <member name="F:Sop.OnDisk.IO.ConcurrentIOData.Event">
            <summary>
            AutoResetEvent Event.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.IO.ConcurrentIOData.Buffer">
            <summary>
            Concurrent I/O buffer.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.IO.ConcurrentIOData.FileStream">
            <summary>
            FileStream.
            </summary>
        </member>
        <member name="T:Sop.Mru.MruManager">
            <summary>
            MRU algorithm. Services MRU objects management in Collections on disk.
            Characteristics are as follows:
            1) Maintains Most Recently Used (MRU) objects in memory
            2) When full, offload objects onto disk using associated CollectionOnDisk (a.k.a. - data store)
            3) If object being accessed is not in memory, automatically loads it from disk and added to MRU pool
            
            NOTE: Full is either maximum count of objects had been reached or memory (RAM) is full, necessitating
            objects offload into disk
            </summary>
        </member>
        <member name="M:Sop.Mru.MruManager.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sop.Mru.MruManager.#ctor(System.Int32,System.Int32,System.Collections.Generic.IComparer{System.Object})" -->
        <member name="F:Sop.Mru.MruManager.RecycledObjects">
            <summary>
            Contains the objects for recycling
            </summary>
        </member>
        <member name="M:Sop.Mru.MruManager.Recycle(System.Collections.Generic.ICollection{System.Object})">
            <summary>
            Add Objects to the RecycledObjects collection
            </summary>
            <param name="objects"></param>
        </member>
        <member name="M:Sop.Mru.MruManager.Recycle(Sop.Persistence.IInternalPersistent)">
            <summary>
            Add Object to the RecycledObjects collection
            </summary>
            <param name="Object"></param>
        </member>
        <member name="M:Sop.Mru.MruManager.GetRecycledObject">
            <summary>
            Attempts to actually recycle an Object from recycle bin(RecycledObjects collection)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.MruManager.SaveRemovedBlocks">
            <summary>
            Save Removed Blocks to target store
            </summary>
        </member>
        <member name="M:Sop.Mru.MruManager.Flush">
            <summary>
            Save the unpersisted MRU items
            </summary>
        </member>
        <member name="M:Sop.Mru.MruManager.SetDataStores(Sop.Mru.IMruClient,Sop.OnDisk.DataBlock.IDataBlockDriver)">
            <summary>
            Binds the DataDriver to the MRUClient(specified by Parent)
            </summary>
            <param name="parent"></param>
            <param name="dataDriver"></param>
        </member>
        <member name="M:Sop.Mru.MruManager.Add(System.Object,System.Object)">
            <summary>
            Add Object to the cache
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sop.Mru.MruManager.Remove(System.Object)">
            <summary>
            Remove Object with key from cache
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.MruManager.Remove(System.Collections.ICollection,System.Boolean)">
            <summary>
            Remove Objects from cache and persist them to target store
            </summary>
            <param name="keys"></param>
            <param name="removeFromCache"></param>
        </member>
        <member name="M:Sop.Mru.MruManager.Remove(System.Object,System.Boolean)">
            <summary>
            Removes entry with key.
            </summary>
            <param name="key">key of entry to delete from collection</param>
            <param name="removeFromCache"> </param>
        </member>
        <member name="M:Sop.Mru.MruManager.Contains(System.Object)">
            <summary>
            Returns true if Key is in MRU, otherwise false
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.MruManager.Clear">
            <summary>
            Set to null all collected items and their internal buffers
            </summary>
        </member>
        <member name="P:Sop.Mru.MruManager.RecycleEnabled">
            <summary>
            true will use cache entry recycling for more efficient memory management.
            otherwise will not
            </summary>
        </member>
        <member name="P:Sop.Mru.MruManager.GeneratePruneEvent">
            <summary>
            get/set flag for Prune event
            </summary>
        </member>
        <member name="P:Sop.Mru.MruManager.SaveState">
            <summary>
            Save State
            </summary>
        </member>
        <member name="P:Sop.Mru.MruManager.Count">
            <summary>
            Returns the number of items in the Manager
            </summary>
        </member>
        <member name="P:Sop.Mru.MruManager.Item(System.Object)">
            <summary>
            Given a key, will return its value.
            If key is not found, will add a new entry having passed 
            params key and value.
            </summary>
        </member>
        <member name="P:Sop.Mru.MruManager.MinCapacity">
            <summary>
            MinCapacity of MRU cache
            </summary>
        </member>
        <member name="P:Sop.Mru.MruManager.MaxCapacity">
            <summary>
            MaxCapacity of MRU cache
            </summary>
        </member>
        <member name="P:Sop.Mru.MruManager.Values">
            <summary>
            Returns the Objects cached
            </summary>
        </member>
        <member name="P:Sop.Mru.MruManager.Keys">
            <summary>
            Returns the Keys of Objects cached
            </summary>
        </member>
        <member name="T:Sop.Log.LogLevels">
            <summary>
            Different Log levels supported
            </summary>
        </member>
        <member name="F:Sop.Log.LogLevels.Verbose">
            <summary>
            Logs verbose output.
            </summary>
        </member>
        <member name="F:Sop.Log.LogLevels.Information">
            <summary>
            Logs basic information.NOTE: conside Info
            </summary>
        </member>
        <member name="F:Sop.Log.LogLevels.Warning">
            <summary>
            Logs a warning.
            </summary>
        </member>
        <member name="F:Sop.Log.LogLevels.Error">
            <summary>
            Logs an error.
            </summary>
        </member>
        <member name="F:Sop.Log.LogLevels.Fatal">
            <summary>
            Logs a fatal incident.
            </summary>
        </member>
        <member name="T:Sop.Collections.BTree.SingleThreadAccess">
            <summary>
               SingleThreadAccess contains api for single thread access to a resource.
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.SingleThreadAccess.Lock">
            <summary>
            Lock this resource for update. This allows only a single thread to get
            access to the resource.
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.SingleThreadAccess.Unlock">
            <summary>
            Unlock this resource so other thread(s) may acquire a Lock on it.
            </summary>
        </member>
        <member name="T:Sop.Collections.BTree.ICollection">
            <summary>
            ICollection defines the BTree "custom" Collection interface
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.ICollection.MoveNext">
            <summary>
            MoveNext makes the next entry the current one
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.ICollection.MovePrevious">
            <summary>
            MovePrevious makes the previous entry the current one
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.ICollection.MoveFirst">
            <summary>
            MoveFirst makes the first entry in the Collection the current one
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.ICollection.MoveLast">
            <summary>
            MoveLast makes the last entry in the Collection the current one
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.ICollection.Search(System.Object)">
            <summary>
            Search the Collection for existence of ObjectToSearch
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.ICollection.Add(System.Object)">
            <summary>
            Add 'ObjectToAdd' to the Collection
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.ICollection.Remove(System.Object)">
            <summary>
            Remove ObjectToRemove from the Collection if found, else throws an exception
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.ICollection.Clear">
            <summary>
            Clear the Collection of all its items
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.ICollection.Clone">
            <summary>
            Shallow copy the Collection and returns a duplicate Collection.
            </summary>
        </member>
        <member name="P:Sop.Collections.BTree.ICollection.Count">
            <summary>
            Returns the count of items stored in the Collection
            </summary>
        </member>
        <member name="P:Sop.Collections.BTree.ICollection.CurrentEntry">
            <summary>
            Returns the Current entry
            </summary>
        </member>
        <member name="T:Sop.Transaction.TransactionRoot">
            <summary>
            Create 1st level Transaction using TransactionRoot.
            SOP uses TransactionRoot for keeping track of lowest
            level transaction activities such as creation of the
            main ObjectServer's File object.
            It is also used to provide 2nd level transaction
            protection such as before writing to the Indexed transaction
            Files, it records the activity detail such as File start Offset
            and count of bytes to be modified so the activity can be rolled
            back if needed.
            </summary>
        </member>
        <member name="F:Sop.Transaction.TransactionRoot.LogFolder">
            <summary>
            Transaction Log folder
            </summary>
        </member>
        <member name="M:Sop.Transaction.TransactionRoot.BeginRoot(System.String)">
            <summary>
            Begin a root transaction
            </summary>
        </member>
        <member name="M:Sop.Transaction.TransactionRoot.InternalCommit(Sop.Transaction.CommitPhase)">
            <summary>
            Commit this transaction
            </summary>
            <param name="phase"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Transaction.TransactionRoot.InternalRollback(System.Boolean)">
            <summary>
            Rollback this transaction
            </summary>
        </member>
        <member name="M:Sop.Transaction.TransactionRoot.RollbackAll(System.String)">
            <summary>
            Rollback all transaction root logs.
            NOTE: invoke this upon app restart
            </summary>
        </member>
        <member name="M:Sop.Transaction.TransactionRoot.RegisterOpenFile(System.String)">
            <summary>
            If File doesn't exist, records its none existence so on Rollback, it can be deleted.
            'doesn't do anything if file exists.
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Sop.Transaction.TransactionRoot.RegisterSave(Sop.OnDisk.Algorithm.Collection.CollectionOnDisk,System.Int64,System.Int32,Sop.OnDisk.IO.ConcurrentIOPoolManager,Sop.OnDisk.IO.ConcurrentIOPoolManager)">
            <summary>
            RegisterSave is the only one we do COW to be able to roll back from text log file
            the last transaction action done.
            </summary>
            <param name="collection"></param>
            <param name="blockAddress"></param>
            <param name="segmentSize"></param>
            <param name="readPool"> </param>
            <param name="writePool"> </param>
        </member>
        <member name="P:Sop.Transaction.TransactionRoot.LogRootFilename">
            <summary>
            Contains the Log root filename.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.TypeStore">
            <summary>
            Type Store
            </summary>
        </member>
        <member name="M:Sop.OnDisk.TypeStore.CreateInstance(Sop.Transaction.ITransactionLogger,System.Int32,System.Collections.Generic.KeyValuePair{System.String,System.Object}[])">
            <summary>
            Create Instance
            </summary>
            <param name="transaction"> </param>
            <param name="typeId"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.TypeStore.RegisterType(System.Object)">
            <summary>
            Register type and return a Type ID.
            </summary>
            <param name="value"> </param>
            <returns>ID(integer) of the type</returns>
        </member>
        <member name="T:Sop.SpecializedDataStore.PersistentTypeKeyValue`2">
            <summary>
            Sorted Dictionary for:
            * IPersistent implementing Key POCO
            * IPersistent implementing Value POCO
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Sop.SpecializedDataStore.PersistentTypeKeyValue`2.GetCollection(Sop.ISortedDictionaryOnDisk,Sop.GenericComparer{`0},System.String,System.Boolean)">
            <summary>
            Override SimpleKeyValue GetCollection to add support for IPersistent Key POCO (de)serialization.
            </summary>
            <param name="container"></param>
            <param name="comparer"></param>
            <param name="name"></param>
            <param name="isDataInKeySegment"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.OnDisk.Geometry.RegionLogic">
            <summary>
            Disk Region Logic.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.Geometry.RegionLogic.IsSegmentInStore(Sop.Collections.Generic.ISortedDictionary{Sop.Transaction.Transaction.RecordKey,System.Int64},Sop.Transaction.Transaction.RecordKey,System.Int32)">
            <summary>
            Checks whether a certain area on disk (segment)
            is inclusive on any of segment entries of the store.
            </summary>
            <param name="fileGrowthStore"></param>
            <param name="key"></param>
            <param name="blockSize"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.OnDisk.Geometry.RegionLogic.RemoveIntersections(Sop.Collections.Generic.ISortedDictionary{Sop.Transaction.Transaction.RecordKey,System.Int64},Sop.Transaction.Transaction.RecordKey,System.Int64,System.Int32)">
            <summary>
            RemoveIntersections will check whether an area on disk was already
            inclusive in any of the segment areas stored as entries in a store (addStore).
            If input area is fully inclusive, this function returns null, otherwise
            it will return a region equivalent to the input area minus any intersecting
            area(s) of segment(s) in the store. 
            </summary>
            <param name="addStore"></param>
            <param name="key"></param>
            <param name="blockAddress"></param>
            <param name="segmentSize"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.Persistence.IPersistentVersioned">
            <summary>
            Versioned Persistent Object interface
            </summary>
        </member>
        <member name="P:Sop.Persistence.IPersistentVersioned.VersionNumber">
            <summary>
            Version Number
            </summary>
        </member>
        <member name="T:Sop.QueryFilterFunc">
            <summary>
            non-generic QueryFilterFunc.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.QueryFilterFunc`1">
            <summary>
            Query Filter Function allows code to submit a function parameter
            that contains user defined logic for further refining comparisons
            done by the Bulk Query/Remove.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>true will signal SOP the record matches, false otherwise.</returns>
        </member>
        <member name="T:Sop.TrashBinType">
            <summary>
            Trash Bin type enumeration
            </summary>
        </member>
        <member name="F:Sop.TrashBinType.Default">
            <summary>
            Default is one trash bin per Collection object.
            </summary>
        </member>
        <member name="F:Sop.TrashBinType.Nothing">
            <summary>
            Nothing means no trash bin. Each data block deleted can't be recycled and will be a wasted space.
            NOTE: this is useful for specialized applications where after index/data file build up, 
            it switch to read only mode thus, not needing any trash or recycle bins.
            </summary>
        </member>
        <member name="T:Sop.Log.Logger">
            <summary>
            Logger wrapper. This utilizes passed in ILogger instance
            for actual logging.
            </summary>
        </member>
        <member name="M:Sop.Log.Logger.#ctor(System.String)">
            <summary>
            Constructor that uses TextLogger for actual logging of messages.
            </summary>
            <param name="logName"></param>
        </member>
        <member name="M:Sop.Log.Logger.#ctor(Sop.Log.ILogger)">
            <summary>
            Constructor expecting a logger instance for doing actual logging.
            </summary>
            <param name="realLogger"></param>
        </member>
        <member name="M:Sop.Log.Logger.Log(System.Exception)">
            <summary>
            Log exception using default log level (error).
            </summary>
            <param name="exc">exception info of which will be logged.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Log(Sop.Log.LogLevels,System.Exception)">
            <summary>
            Log exception with given log level.
            </summary>
            <param name="logLevel">Log Level</param>
            <param name="exc">exception to log</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Log(System.Exception,System.String,System.Object[])">
            <summary>
            Log exception on default log level (error) with add'l formatable text msg and optional messageArgs.
            </summary>
            <param name="exc">exception to be logged.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Log(Sop.Log.LogLevels,System.Exception,System.String,System.Object[])">
            <summary>
            Log exception on given log level with add'l formatable text msg and optional messageArgs.
            </summary>
            <param name="logLevel">Log Level</param>
            <param name="exc">exception to be logged.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Log(Sop.Log.LogLevels,System.String,System.Object[])">
            <summary>
            Log a formatable text and optional messageArgs.
            </summary>
            <param name="logLevel">Log Level</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Verbose(System.Exception)">
            <summary>
            Log exception in verbose log level.
            </summary>
            <param name="exc">exception to be logged.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Verbose(System.Exception,System.String,System.Object[])">
            <summary>
            Log exception in verbose log level with add'l formatable text msg and optional messageArgs.
            </summary>
            <param name="exc">exception to be logged.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Verbose(System.String,System.Object[])">
            <summary>
            Log formatable text msg and optional messageArgs in verbose log level.
            </summary>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Error(System.Exception)">
            <summary>
            Log exception with error log level.
            </summary>
            <param name="exc">exception to be logged.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Log exception on error log level with add'l formatable text msg and optional messageArgs.
            </summary>
            <param name="exc">exception to be logged.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Error(System.String,System.Object[])">
            <summary>
            Log formatable text msg and optional messageArgs on error log level.
            </summary>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Information(System.Exception)">
            <summary>
            Log exception on Information log level.
            </summary>
            <param name="exc">exception to be logged.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Information(System.Exception,System.String,System.Object[])">
            <summary>
            Log exception on Information log level with add'l formatable text msg and optional messageArgs.
            </summary>
            <param name="exc">exception to be logged.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Information(System.String,System.Object[])">
            <summary>
            Log formatable text msg and optional messageArgs on Information log level.
            </summary>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Fatal(System.Exception)">
            <summary>
            Log exception on Fatal log level.
            </summary>
            <param name="exc"></param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Fatal(System.Exception,System.String,System.Object[])">
            <summary>
            Log exception, formatable text msg and optional messageArgs on Fatal log level.
            </summary>
            <param name="exc">exception to be logged.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Fatal(System.String,System.Object[])">
            <summary>
            Log formatable text msg and optional messageArgs on Fatal log level.
            </summary>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Warning(System.Exception)">
            <summary>
            Log exception on Warning log level.
            </summary>
            <param name="exc">exception to be logged.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Warning(System.Exception,System.String,System.Object[])">
            <summary>
            Log exception, formatable text msg and optional messageArgs on Warning log level.
            </summary>
            <param name="exc">exception to be logged.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Warning(System.String,System.Object[])">
            <summary>
            Log formatable text msg and optional messageArgs on Warning log level.
            </summary>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Format(System.Exception,System.String,System.Object[])">
            <summary>
            Utility function for Formatting exception, text msg and optional messageArgs.
            </summary>
            <param name="exc">exception to be logged.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Format(System.String,System.Object[])">
            <summary>
            Utility function for Formatting text msg and optional messageArgs.
            </summary>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Format(System.Text.StringBuilder,System.Exception,System.String,System.Object[])">
            <summary>
            Utility function for Formatting exception, text msg and optional messageArgs.
            </summary>
            <param name="target">Target StringBuilder where we append message and their optional arguments.</param>
            <param name="exc">exception to be logged.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.Format(System.Text.StringBuilder,System.String,System.Object[])">
            <summary>
            Utility function for Formatting text msg and optional messageArgs.
            </summary>
            <param name="target">Target StringBuilder where we append message and their optional arguments.</param>
            <param name="messageFormat">Text message containing formatting section.</param>
            <param name="messageArgs">Arguments to be rendered/formatted part of the Text message.</param>
            <returns>Actual formatted text that got logged.</returns>
        </member>
        <member name="M:Sop.Log.Logger.IsLogLevelEnabled(Sop.Log.LogLevels)">
            <summary>
            Is given log level logging enabled.
            </summary>
            <param name="logLevel">Log Level</param>
            <returns>true if Log Level is enabled, otherwise false.</returns>
        </member>
        <member name="F:Sop.Log.Logger.RealLogger">
            <summary>
            Real logger instance.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.DefaultLogDirectory">
            <summary>
            Default Log Directory.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.LogLevel">
            <summary>
            LogLevel set.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.Instance">
            <summary>
            Singleton instance of Logger.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.IsVerboseEnabled">
            <summary>
            Is Verbose logging enabled.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.IsErrorEnabled">
            <summary>
            Is Error logging enabled.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.IsFatalEnabled">
            <summary>
            Is Fatal logging enabled.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.IsInformationEnabled">
            <summary>
            Is Information logging enabled.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.IsWarningEnabled">
            <summary>
            Is Warning logging enabled.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.Name">
            <summary>
            Name of this Logger.
            </summary>
        </member>
        <member name="P:Sop.Log.Logger.LogContextData">
            <summary>
            Returns the Log context data dictionary.
            All entries (ie - both Name and Value pair) in the log context dictionary 
            will be written as prefix for each log Log Facade generates. It can be useful
            for things like easily specifying Logged in user info that makes it to the
            logs the application is generating.
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruItem`2.Transaction">
            <summary>
            Transaction this block belongs to
            </summary>
        </member>
        <member name="T:Sop.OnDisk.ISession">
            <summary>
            Session interface.
            </summary>
        </member>
        <member name="M:Sop.OnDisk.ISession.Register(Sop.OnDisk.ObjectServer)">
            <summary>
            Register open/create of an object server.
            </summary>
            <param name="objectServer"></param>
        </member>
        <member name="M:Sop.OnDisk.ISession.Register(Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk)">
            <summary>
            Register open/create of a dictionary on disk.
            </summary>
            <param name="dictionaryOnDisk"></param>
        </member>
        <member name="M:Sop.OnDisk.ISession.UnRegister(Sop.OnDisk.ObjectServer)">
            <summary>
            Unregister an object server.
            </summary>
            <param name="objectServer"></param>
        </member>
        <member name="M:Sop.OnDisk.ISession.UnRegister(Sop.OnDisk.Algorithm.SortedDictionary.SortedDictionaryOnDisk)">
            <summary>
            Unregister a sorted dictionary on disk.
            </summary>
            <param name="dictionaryOnDisk"></param>
        </member>
        <member name="P:Sop.OnDisk.ISession.Id">
            <summary>
            ID of the session.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.ISession.Transaction">
            <summary>
            Session Transaction.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.PersistenceType">
            <summary>
            Enumerates SOP supported Persistence Types
            </summary>
        </member>
        <member name="F:Sop.OnDisk.PersistenceType.Unknown">
            <summary>
            Unknown Persistent Type
            </summary>
        </member>
        <member name="F:Sop.OnDisk.PersistenceType.Custom">
            <summary>
            Custom serialization.
            Samples:
            - IPersistent derived class
            - XML serialization
            - in the future, other custom classified 
            serialization methods can be added
            </summary>
        </member>
        <member name="F:Sop.OnDisk.PersistenceType.SimpleType">
            <summary>
            e.g. - int, int32, long, char, byte, short, ushort, float, ufloat, double, udouble,
            decimal, uint
            </summary>
        </member>
        <member name="F:Sop.OnDisk.PersistenceType.String">
            <summary>
            Serialize string
            </summary>
        </member>
        <member name="F:Sop.OnDisk.PersistenceType.ByteArray">
            <summary>
            Serialize a Byte Array.
            </summary>
        </member>
        <member name="F:Sop.OnDisk.PersistenceType.BinarySerialized">
            <summary>
            Binary Serialized data
            </summary>
        </member>
        <member name="F:Sop.OnDisk.PersistenceType.Null">
            <summary>
            Serialize "null" as a 1 byte value on disk representing null
            value for a reference type object.
            </summary>
        </member>
        <member name="T:Sop.QueryExpression">
            <summary>
            Query expression. Exact key matching and an option to 
            filter on an entry's value is supported.
            LINQ queries may be supported in future.
            </summary>
        </member>
        <member name="F:Sop.QueryExpression.Key">
            <summary>
            Set this to value of the Key to be searched.
            </summary>
        </member>
        <member name="F:Sop.QueryExpression.ValueFilterFunc">
            <summary>
            (optional) Set this to a user defined filter function
            that can further refine the query matching.
            </summary>
        </member>
        <member name="T:Sop.QueryExpression`1">
            <summary>
            Generic Query expression. Exact key matching and an option to 
            filter on an entry's value is supported.
            LINQ queries may be supported in future.
            </summary>
            <typeparam name="TKey"> </typeparam>
        </member>
        <member name="F:Sop.QueryExpression`1.Key">
            <summary>
            Set this to value of the Key to be searched.
            </summary>
        </member>
        <member name="F:Sop.QueryExpression`1.ValueFilterFunc">
            <summary>
            (optional) Set this to a user defined filter function
            that can further refine the query matching, extend it to do matching
            on the Value object in the Key/Value pair entry of the Store.
            </summary>
        </member>
        <member name="M:Sop.QueryExpression`1.Package(`0[])">
            <summary>
            Package a given set of Keys as an array of QueryExpressions.
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.QueryExpression`1.Convert">
            <summary>
            Convert to non-generic QueryExpression.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.QueryExpression`1.Convert(Sop.QueryExpression{`0}[])">
            <summary>
            Convert array of generic QueryExpression into non-generic.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Sop.Recycling.DataBlockRecycler">
            <summary>
            DataBlock specific recycler.
            </summary>
        </member>
        <member name="T:Sop.Mru.SaveTypes">
            <summary>
            SaveTypes enumeration
            </summary>
        </member>
        <member name="F:Sop.Mru.SaveTypes.Default">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Sop.Mru.SaveTypes.CollectionSave">
            <summary>
            Collection Save function triggered the Save session
            </summary>
        </member>
        <member name="F:Sop.Mru.SaveTypes.DataPoolInMaxCapacity">
            <summary>
            Save session was triggered by the Data Pool getting into its Max capacity
            </summary>
        </member>
        <member name="T:Sop.GenericComparer`1">
            <summary>
            Generic Comparer wrapper.
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="M:Sop.GenericComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructor
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Sop.GenericComparer`1.Compare(System.Object,System.Object)">
            <summary>
            Compare a key with another
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="F:Sop.GenericComparer`1.Comparer">
            <summary>
            The real Comparer.
            </summary>
        </member>
        <member name="T:Sop.Utility.Crypto">
            <summary>
            SOP's internal Cryptography class.
            </summary>
        </member>
        <member name="M:Sop.Utility.Crypto.EncryptString(System.String,System.String)">
            <summary> 
            Encrypt the given string using AES.  The string can be decrypted using  
            DecryptString().  The sharedSecret parameters must match. 
            </summary> 
            <param name="plainText">The text to encrypt.</param> 
            <param name="sharedSecret">A password used to generate a key for encryption.</param> 
        </member>
        <member name="M:Sop.Utility.Crypto.DecryptString(System.String,System.String)">
            <summary> 
            Decrypt the given string.  Assumes the string was encrypted using  
            EncryptString(), using an identical sharedSecret. 
            </summary> 
            <param name="cipherText">The text to decrypt.</param> 
            <param name="sharedSecret">A password used to generate a key for decryption.</param> 
        </member>
        <member name="T:Sop.Transaction.ActionType">
            <summary>
            Action Type enumeration
            </summary>
        </member>
        <member name="F:Sop.Transaction.ActionType.Add">
            <summary>
            Add item to collection
            </summary>
        </member>
        <member name="F:Sop.Transaction.ActionType.Remove">
            <summary>
            Remove item from collection
            </summary>
        </member>
        <member name="F:Sop.Transaction.ActionType.Save">
            <summary>
            Save changes of a collection
            </summary>
        </member>
        <member name="F:Sop.Transaction.ActionType.Grow">
            <summary>
            Grow the collection
            </summary>
        </member>
        <member name="F:Sop.Transaction.ActionType.Recycle">
            <summary>
            Recycle removed block(s)
            </summary>
        </member>
        <member name="F:Sop.Transaction.ActionType.RecycleCollection">
            <summary>
            Recycle a removed collection
            </summary>
        </member>
        <member name="T:Sop.Profile">
            <summary>
            Profile contains all variable settings user can tweak to change
            SOP performance and data allocations on disk.
            </summary>
        </member>
        <member name="M:Sop.Profile.#ctor(Sop.Preferences)">
            <summary>
            Constructor
            </summary>
            <param name="profileScheme"></param>
            <param name="dataBlockSize"></param>
            <param name="collectionSegmentSize"></param>
            <param name="maxInMemoryBlockCount"></param>
        </member>
        <member name="P:Sop.Profile.CollectionSegmentSize">
            <summary>
            Data segment size on disk. Multiple POCOs can be stored
            in one segment, depending on POCO's serialized data size.
            This defaults to 
            </summary>
        </member>
        <member name="P:Sop.Profile.CollectionGrowthSizeInNob">
            <summary>
            Collection on disk growth size in number of blocks
            </summary>
        </member>
        <member name="P:Sop.Profile.MruMinCapacity">
            <summary>
            MRU Minimum Capacity
            </summary>
        </member>
        <member name="P:Sop.Profile.MruMaxCapacity">
            <summary>
            MRU Maximum Capacity
            </summary>
        </member>
        <member name="P:Sop.Profile.MaxInMemoryBlockCount">
            <summary>
            Maximum count of data blocks to hold in memory before triggering a flush to disk
            of SOP block buffers.
            </summary>
        </member>
        <member name="P:Sop.Profile.MaxOpenedFileStreamCount">
            <summary>
            getter/setter for maximum number of opened file stream supported by SOP.
            </summary>
        </member>
        <member name="P:Sop.Profile.MaxConcurrentIO">
            <summary>
            Maximum number of concurrent I/O threads allowed in Concurrent IO Pool Manager
            which is used by Data Manager during bulk I/O operations on times of page
            swap to disk cases.
            </summary>
        </member>
        <member name="T:Sop.Utility.Utility">
            <summary>
            Utility contains standalone unclassified methods providing
            useful functionalities. Currently contains mostly File I/O
            shortcut/wrapper functions.
            </summary>
        </member>
        <member name="T:Sop.Transaction.NoTransactionLogger">
            <summary>
            A blank Transaction Logger. Function overrides are meant to do nothing.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.IO.ConcurrentIOPoolManager">
            <summary>
            Concurrent I/O Pool manager.
            </summary>
        </member>
        <member name="P:Sop.OnDisk.IO.ConcurrentIOPoolManager.MaxConcurrentIO">
            <summary>
            Maximum number of concurrent IO. Defaults to 32.
            </summary>
        </member>
        <member name="T:Sop.Mru.Generic.ConcurrentMruManager`2">
            <summary>
            Thread Safe MRU Manager.
            </summary>
        </member>
        <member name="M:Sop.Mru.Generic.ConcurrentMruManager`2.SetDataStores(Sop.Mru.IMruClient)">
            <summary>
            Binds the MRU Client to the DataDriver. DataDriver is used
            for persistence of cached Objects to target store
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:Sop.Mru.Generic.ConcurrentMruManager`2.PeekInTail">
            <summary>
            Peek in tail.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.Generic.ConcurrentMruManager`2.RemoveInTail">
            <summary>
            Remove in tail.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sop.Mru.Generic.ConcurrentMruManager`2.MruItems">
            <summary>
            Returns Objects in cache
            </summary>
        </member>
        <member name="T:Sop.Collections.BTree.IDictionary">
            <summary>
            Extends the Collections.BTreeICollection interface and adds Dictionary related api
            </summary>
        </member>
        <member name="M:Sop.Collections.BTree.IDictionary.Add(System.Object,System.Object)">
            <summary>
            Add Key and Value as entry to the Dictionary/Collection
            </summary>
        </member>
        <member name="P:Sop.Collections.BTree.IDictionary.CurrentKey">
            <summary>
            Returns the Current entry's key
            </summary>
        </member>
        <member name="P:Sop.Collections.BTree.IDictionary.CurrentValue">
            <summary>
            Returns the Current entry's Value
            </summary>
        </member>
        <member name="T:Sop.DataBlockSize">
            <summary>
            DataBlockSize enumeration.
            
            NOTE: large block sizes were defined with intent of supporting persistence
            of POCOs with large blobs of data, e.g. - media. However, pls. use caution
            in selecting your data block size, we recommend using the smaller sizes
            as the "large" sizes typically generates huge File sizes with a lot of
            unused space. They also impact in-memory caching.
            
            NOTE 2: SOP's extension for large blobs will be tackled in a future release.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.Unknown">
            <summary>
            Unknown block size.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.Zero">
            <summary>
            0 byte.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.Minimum">
            <summary>
            Minimum Data Block size is 512 bytes.
            This size is mainly dictated by the limits of Win32 file system
            per single readable sector on disk.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.FiveTwelve">
            <summary>
            512 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.TenTwentyFour">
            <summary>
            1024 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.TwentyFortyEight">
            <summary>
            2048 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.FortyNinetySix">
            <summary>
            4096 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.EightyOneNinetyTwo">
            <summary>
            8192 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.SixteenThreeEightyFour">
            <summary>
            16384 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.ThirtyTwoSevenSixtyEight">
            <summary>
            32768 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.SixtyFiveFiveThreeSix">
            <summary>
            65536 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.OneThreeTenSeventyTwo">
            <summary>
            131072 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.TwoSixtyTwoOneFortyFour">
            <summary>
            262144 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.FiveTwentyFourTwoEightyEight">
            <summary>
            524288 bytes.
            </summary>
        </member>
        <member name="F:Sop.DataBlockSize.Maximum">
            <summary>
            Maximum is 524288 bytes.
            </summary>
        </member>
        <member name="T:Sop.OnDisk.UpdateCountType">
            <summary>
            Update Count Type
            </summary>
        </member>
        <member name="F:Sop.OnDisk.UpdateCountType.Increment">
            <summary>
            Increment Count
            </summary>
        </member>
        <member name="F:Sop.OnDisk.UpdateCountType.Decrement">
            <summary>
            Decrement Count
            </summary>
        </member>
        <member name="T:Sop.Mru.Generic.MruManager`2">
            <summary>
            MRU algorithm. Services MRU objects management in Collections on disk.
            Characteristics are as follows:
            1) Maintains Most Recently Used (MRU) objects in memory
            2) When full, offload objects onto disk using associated CollectionOnDisk (a.k.a. - data store)
            3) If object being accessed is not in memory, automatically loads it from disk and added to MRU pool
            
            NOTE: Full is either maximum count of objects had been reached or memory (RAM) is full, necessitating
            objects offload into disk
            </summary>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sop.Mru.Generic.MruManager`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" -->
        <!-- Badly formed XML comment ignored for member "M:Sop.Mru.Generic.MruManager`2.GetFromTail" -->
        <member name="F:Sop.Mru.Generic.MruManager`2.RecycleEnabled">
            <summary>
            true will use cache entry recycling for more efficient memory management.
            otherwise will not
            </summary>
        </member>
        <member name="F:Sop.Mru.Generic.MruManager`2.RecycledObjects">
            <summary>
            Contains the objects for recycling
            </summary>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.Recycle(System.Collections.Generic.IEnumerable{Sop.Persistence.IInternalPersistent})">
            <summary>
            Add Objects to the RecycledObjects collection
            </summary>
            <param name="objects"></param>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.Recycle(Sop.Persistence.IInternalPersistent)">
            <summary>
            Add Object to the RecycledObjects collection
            </summary>
            <param name="Object"></param>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.GetRecycledObject">
            <summary>
            Attempts to actually recycle an Object from recycle bin(RecycledObjects collection)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.SaveRemovedBlocks">
            <summary>
            Save Removed Blocks to target store
            </summary>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.Flush">
            <summary>
            Save the unpersisted MRU items
            </summary>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.SetDataStores(Sop.Mru.IMruClient)">
            <summary>
            Binds this MRU Manager to a MRUClient(Parent)
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.Add(`0,`1)">
            <summary>
            Add Object to the cache
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.Remove(System.Collections.Generic.ICollection{`0})">
            <summary>
            Remove Objects from cache and persist them to target store
            </summary>
            <param name="keys"></param>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.Remove(`0)">
            <summary>
            Removes entry with key.
            </summary>
            <param name="key">key of entry to delete from collection</param>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.Contains(`0)">
            <summary>
            Returns true if Key is in MRU, otherwise false
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Sop.Mru.Generic.MruManager`2.Clear">
            <summary>
            Set to null all collected items and their internal buffers
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.IsFull">
            <summary>
            true if MRU is in MaxCapacity, false otherwise.
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.GeneratePruneEvent">
            <summary>
            get/set flag for Prune event
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.SaveState">
            <summary>
            Save State
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.Count">
            <summary>
            Returns the number of items in the Manager
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.Item(`0)">
            <summary>
            Given a key, will return its value.
            If key is not found, will add a new entry having passed 
            params key and value.
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.MinCapacity">
            <summary>
            MinCapacity of MRU cache
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.MaxCapacity">
            <summary>
            MaxCapacity of MRU cache
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.Values">
            <summary>
            Returns the Objects cached
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.MruItems">
            <summary>
            Returns the Objects cached
            </summary>
        </member>
        <member name="P:Sop.Mru.Generic.MruManager`2.Keys">
            <summary>
            Returns the Keys of Objects cached
            </summary>
        </member>
        <member name="T:Sop.Collections.Generic.ICollection`1">
            <summary>
            In-Memory Collection interface.
            </summary>
        </member>
        <member name="M:Sop.Collections.Generic.ICollection`1.Add(`0)">
            <summary>
            Add entry to the Dictionary/Collection.
            </summary>
        </member>
        <member name="P:Sop.Collections.Generic.ICollection`1.CurrentEntry">
            <summary>
            Returns the Current entry.
            </summary>
        </member>
    </members>
</doc>
